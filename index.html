<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Virtual Piano – Dual Oscillator Synth + MIDI</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    h1 {
      margin: 0 0 8px;
      font-size: 20px;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
    }

    .panel {
      background: #181818;
      border-radius: 8px;
      padding: 12px;
      flex: 1 1 360px;
      box-shadow: 0 0 0 1px #333;
    }

    .panel h2 {
      margin-top: 0;
      font-size: 16px;
      margin-bottom: 8px;
    }

    .section-title {
      font-size: 13px;
      margin: 8px 0 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: #aaa;
    }

    .control-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 8px;
      align-items: center;
      font-size: 13px;
    }

    label {
      font-size: 12px;
    }

    input[type="range"] {
      width: 100%;
    }

    select {
      width: 100%;
      background: #222;
      color: #eee;
      border-radius: 4px;
      border: 1px solid #444;
      padding: 2px 4px;
      font-size: 12px;
    }

    .keyboard {
      display: flex;
      gap: 2px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    .key {
      position: relative;
      border-radius: 3px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      cursor: default;
      user-select: none;
      text-align: center;
      padding-bottom: 4px;
    }

    .white-key {
      width: 32px;
      height: 90px;
      background: #f5f5f5;
      color: #000;
      border: 1px solid #333;
      z-index: 1;
    }

    .black-key {
      width: 22px;
      height: 70px;
      background: #000;
      color: #fff;
      border: 1px solid #555;
      margin: 0 -10px;
      z-index: 2;
    }

    .key.active.white-key {
      background: #ffd54f;
    }

    .key.active.black-key {
      background: #ffb300;
    }

    .harmonics-container {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 140px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .harmonic-row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 4px 8px;
      align-items: center;
      font-size: 11px;
    }

    .small {
      font-size: 11px;
      color: #999;
    }

    .kbd-help {
      font-size: 12px;
      color: #ccc;
      margin-bottom: 4px;
    }

    .key-label {
      font-weight: 600;
      margin-bottom: 2px;
    }

    .key-note {
      font-size: 10px;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>Virtual Piano – Dual Oscillator Synth + MIDI</h1>
  <div class="kbd-help">
    <div>Keyboard 1: <b>Tab 1 Q 2 W 3 E 4 R 5 T 6 Y 7 U 8 I 9 O 0 P - [ = ] \</b></div>
    <div>Keyboard 2: <b>Z S X D C F V G B H N J M K , L . ; /</b></div>
    <div>
      White keys are fixed: QWERTYUIOP[]\ and ZXCVBNM,./.
      Roots are chosen from those whites. White rows follow Ionian; black keys show only non-scale accidentals (no duplicates of white notes).
    </div>
  </div>

  <div class="row">
    <!-- Instrument 1 -->
    <div class="panel" id="panel1">
      <h2>Keyboard 1 (Top row)</h2>

      <div class="section-title">Oscillator & Envelope</div>
      <div class="control-group">
        <label for="waveform1">Waveform</label>
        <select id="waveform1">
          <option value="sine">Sine</option>
          <option value="square">Square</option>
          <option value="sawtooth">Sawtooth</option>
          <option value="triangle">Triangle</option>
        </select>

        <label for="attack1">Attack (s)</label>
        <input id="attack1" type="range" min="0" max="1.5" step="0.01" value="0.1" />

        <label for="decay1">Decay (s)</label>
        <input id="decay1" type="range" min="0" max="1.5" step="0.01" value="0.1" />

        <label for="sustain1">Sustain (0–1)</label>
        <input id="sustain1" type="range" min="0" max="1" step="0.01" value="0.7" />

        <label for="release1">Release (s)</label>
        <input id="release1" type="range" min="0" max="2.5" step="0.01" value="0.4" />
      </div>

      <div class="section-title">Root, Transpose & Volume</div>
      <div class="control-group">
        <label for="rootKey1">Root key (Ionian)</label>
        <select id="rootKey1"></select>

        <label for="transposeNote1">Root note</label>
        <select id="transposeNote1"></select>

        <label for="transposeOctave1">Octave</label>
        <select id="transposeOctave1"></select>

        <label for="volume1">Volume</label>
        <input id="volume1" type="range" min="0" max="1" step="0.01" value="0.3" />
      </div>

      <div class="section-title">Harmonics</div>
      <div class="control-group">
        <label for="numHarmonics1">Number of harmonics</label>
        <input id="numHarmonics1" type="range" min="1" max="8" step="1" value="3" />
      </div>
      <div id="harmonics1" class="harmonics-container"></div>
      <div class="small">Harmonic 1 is the fundamental, higher numbers are overtones.</div>

      <div class="section-title">Fricative (Noise)</div>
      <div class="control-group">
        <label for="noise1">Noise mix</label>
        <input id="noise1" type="range" min="0" max="1" step="0.01" value="0.05" />

        <label for="noisePitch1">Noise pitch (cutoff)</label>
        <input id="noisePitch1" type="range" min="100" max="8000" step="10" value="800" />
      </div>

      <div class="section-title">Reverb</div>
      <div class="control-group">
        <label for="reverbTime1">Length (s)</label>
        <input id="reverbTime1" type="range" min="0.1" max="5" step="0.1" value="2" />

        <label for="reverbWet1">Wet mix</label>
        <input id="reverbWet1" type="range" min="0" max="1" step="0.01" value="0.3" />
      </div>

      <div class="section-title">Keys</div>
      <div class="keyboard" id="visualKbd1">
        <div class="key" data-key="tab" data-label="Tab"></div>
        <div class="key" data-key="1" data-label="1"></div>
        <div class="key" data-key="q" data-label="Q"></div>
        <div class="key" data-key="2" data-label="2"></div>
        <div class="key" data-key="w" data-label="W"></div>
        <div class="key" data-key="3" data-label="3"></div>
        <div class="key" data-key="e" data-label="E"></div>
        <div class="key" data-key="4" data-label="4"></div>
        <div class="key" data-key="r" data-label="R"></div>
        <div class="key" data-key="5" data-label="5"></div>
        <div class="key" data-key="t" data-label="T"></div>
        <div class="key" data-key="6" data-label="6"></div>
        <div class="key" data-key="y" data-label="Y"></div>
        <div class="key" data-key="7" data-label="7"></div>
        <div class="key" data-key="u" data-label="U"></div>
        <div class="key" data-key="8" data-label="8"></div>
        <div class="key" data-key="i" data-label="I"></div>
        <div class="key" data-key="9" data-label="9"></div>
        <div class="key" data-key="o" data-label="O"></div>
        <div class="key" data-key="0" data-label="0"></div>
        <div class="key" data-key="p" data-label="P"></div>
        <div class="key" data-key="-" data-label="-"></div>
        <div class="key" data-key="[" data-label="["></div>
        <div class="key" data-key="=" data-label="="></div>
        <div class="key" data-key="]" data-label="]"></div>
        <div class="key" data-key="backspace" data-label="Backspace"></div>
        <div class="key" data-key="\" data-label="\"></div>
      </div>
    </div>

    <!-- Instrument 2 -->
    <div class="panel" id="panel2">
      <h2>Keyboard 2 (Bottom row)</h2>

      <div class="section-title">Oscillator & Envelope</div>
      <div class="control-group">
        <label for="waveform2">Waveform</label>
        <select id="waveform2">
          <option value="sine" selected>Sine</option>
          <option value="square">Square</option>
          <option value="sawtooth">Sawtooth</option>
          <option value="triangle">Triangle</option>
        </select>

        <label for="attack2">Attack (s)</label>
        <input id="attack2" type="range" min="0" max="10" step="0.01" value="5" />

        <label for="decay2">Decay (s)</label>
        <input id="decay2" type="range" min="0" max="15" step="0.01" value="10" />

        <label for="sustain2">Sustain (0–1)</label>
        <input id="sustain2" type="range" min="0" max="1" step="0.01" value="0.7" />

        <label for="release2">Release (s)</label>
        <input id="release2" type="range" min="0" max="2.5" step="0.01" value="0.4" />
      </div>

      <div class="section-title">Root, Transpose & Volume</div>
      <div class="control-group">
        <label for="rootKey2">Root key (Ionian)</label>
        <select id="rootKey2"></select>

        <label for="transposeNote2">Root note</label>
        <select id="transposeNote2"></select>

        <label for="transposeOctave2">Octave</label>
        <select id="transposeOctave2"></select>

        <label for="volume2">Volume</label>
        <input id="volume2" type="range" min="0" max="1" step="0.01" value="0.3" />
      </div>

      <div class="section-title">Harmonics</div>
      <div class="control-group">
        <label for="numHarmonics2">Number of harmonics</label>
        <input id="numHarmonics2" type="range" min="1" max="8" step="1" value="5" />
      </div>
      <div id="harmonics2" class="harmonics-container"></div>
      <div class="small">Shape this differently from Keyboard 1 for layering.</div>

      <div class="section-title">Fricative (Noise)</div>
      <div class="control-group">
        <label for="noise2">Noise mix</label>
        <input id="noise2" type="range" min="0" max="1" step="0.01" value="0.1" />

        <label for="noisePitch2">Noise pitch (cutoff)</label>
        <input id="noisePitch2" type="range" min="100" max="8000" step="10" value="400" />
      </div>

      <div class="section-title">Reverb</div>
      <div class="control-group">
        <label for="reverbTime2">Length (s)</label>
        <input id="reverbTime2" type="range" min="0.1" max="5" step="0.1" value="2.5" />

        <label for="reverbWet2">Wet mix</label>
        <input id="reverbWet2" type="range" min="0" max="1" step="0.01" value="0.4" />
      </div>

      <div class="section-title">Keys</div>
      <div class="keyboard" id="visualKbd2">
        <div class="key" data-key="z" data-label="Z"></div>
        <div class="key" data-key="s" data-label="S"></div>
        <div class="key" data-key="x" data-label="X"></div>
        <div class="key" data-key="d" data-label="D"></div>
        <div class="key" data-key="c" data-label="C"></div>
        <div class="key" data-key="f" data-label="F"></div>
        <div class="key" data-key="v" data-label="V"></div>
        <div class="key" data-key="g" data-label="G"></div>
        <div class="key" data-key="b" data-label="B"></div>
        <div class="key" data-key="h" data-label="H"></div>
        <div class="key" data-key="n" data-label="N"></div>
        <div class="key" data-key="j" data-label="J"></div>
        <div class="key" data-key="m" data-label="M"></div>
        <div class="key" data-key="k" data-label="K"></div>
        <div class="key" data-key="," data-label=","></div>
        <div class="key" data-key="l" data-label="L"></div>
        <div class="key" data-key="." data-label="."></div>
        <div class="key" data-key=";" data-label=";"></div>
        <div class="key" data-key="/" data-label="/"></div>
      </div>
    </div>

    <!-- Instrument 3 (MIDI) -->
    <div class="panel" id="panel3">
      <h2>Keyboard 3 (MIDI controller)</h2>

      <div class="section-title">MIDI Input</div>
      <div class="control-group">
        <label for="midiInputSelect3">MIDI device</label>
        <select id="midiInputSelect3"></select>

        <label for="midiChannel3">Channel</label>
        <select id="midiChannel3"></select>
      </div>
      <div id="midiStatus3" class="small">Looking for MIDI devices…</div>

      <div class="section-title">Oscillator & Envelope</div>
      <div class="control-group">
        <label for="waveform3">Waveform</label>
        <select id="waveform3">
          <option value="sine" selected>Sine</option>
          <option value="square">Square</option>
          <option value="sawtooth">Sawtooth</option>
          <option value="triangle">Triangle</option>
        </select>

        <label for="attack3">Attack (s)</label>
        <input id="attack3" type="range" min="0" max="2" step="0.01" value="0.03" />

        <label for="decay3">Decay (s)</label>
        <input id="decay3" type="range" min="0" max="2" step="0.01" value="0.2" />

        <label for="sustain3">Sustain (0–1)</label>
        <input id="sustain3" type="range" min="0" max="1" step="0.01" value="0.9" />

        <label for="release3">Release (s)</label>
        <input id="release3" type="range" min="0" max="4" step="0.01" value="0.5" />

        <label for="volume3">Volume</label>
        <input id="volume3" type="range" min="0" max="1" step="0.01" value="0.3" />
      </div>

      <div class="section-title">Harmonics</div>
      <div class="control-group">
        <label for="numHarmonics3">Number of harmonics</label>
        <input id="numHarmonics3" type="range" min="1" max="8" step="1" value="4" />
      </div>
      <div id="harmonics3" class="harmonics-container"></div>

      <div class="section-title">Fricative (Noise)</div>
      <div class="control-group">
        <label for="noise3">Noise mix</label>
        <input id="noise3" type="range" min="0" max="1" step="0.01" value="0.02" />

        <label for="noisePitch3">Noise pitch (cutoff)</label>
        <input id="noisePitch3" type="range" min="100" max="8000" step="10" value="1200" />
      </div>

      <div class="section-title">Reverb</div>
      <div class="control-group">
        <label for="reverbTime3">Length (s)</label>
        <input id="reverbTime3" type="range" min="0.1" max="5" step="0.1" value="2.2" />

        <label for="reverbWet3">Wet mix</label>
        <input id="reverbWet3" type="range" min="0" max="1" step="0.01" value="0.35" />
      </div>

      <div class="section-title">MIDI Event Log</div>
      <div id="midiLog3" class="harmonics-container small"></div>
    </div>
  </div>

  <script>
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContextClass();

    // Ionian intervals (for white-key scale steps)
    const IONIAN_INTERVALS = [2, 2, 1, 2, 2, 2, 1];
    const IONIAN_SET = new Set([0, 2, 4, 5, 7, 9, 11]); // scale degrees from root

    function ionianOffset(steps) {
      if (steps === 0) return 0;
      let semis = 0;
      if (steps > 0) {
        for (let i = 0; i < steps; i++) {
          semis += IONIAN_INTERVALS[i % IONIAN_INTERVALS.length];
        }
      } else {
        const count = -steps;
        for (let i = 0; i < count; i++) {
          const idx = IONIAN_INTERVALS.length - 1 - (i % IONIAN_INTERVALS.length);
          semis -= IONIAN_INTERVALS[idx];
        }
      }
      return semis;
    }

    function midiToFreq(m) {
      return 440 * Math.pow(2, (m - 69) / 12);
    }

    function midiToName(m) {
      const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const n = ((m % 12) + 12) % 12;
      const octave = Math.floor(m / 12) - 1;
      return names[n] + octave;
    }

    // Physical sequences
    const board1Seq = [
      'tab','1','q','2','w','3','e','4','r','5',
      't','6','y','7','u','8','i','9','o','0',
      'p','-','[','=',']','backspace','\\'
    ];

    const board2Seq = [
      'z','s','x','d','c','f','v','g','b','h',
      'n','j','m','k',',','l','.',';','/'
    ];

    // White keys (fixed "piano whites")
    const whiteKeys1 = ['tab', 'q','w','e','r','t','y','u','i','o','p','[',']','\\'];
    const whiteKeys2 = ['z','x','c','v','b','n','m',',','.','/'];
    const whiteSet1 = new Set(whiteKeys1);
    const whiteSet2 = new Set(whiteKeys2);

    // key -> midi per instrument
    const keyMidi = {}; // `${instr}:${key}` -> midi

    const STORAGE_KEY = 'virtualPianoSettings';
    const PERSISTED_FIELDS = [
      'waveform','attack','decay','sustain','release','numHarmonics',
      'noise','noiseCutoff','reverbTime','reverbWet','transposeNote',
      'transposeOctave','volume','rootKey'
    ];

    function clamp(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        return raw ? JSON.parse(raw) : null;
      } catch (err) {
        console.warn('Could not load settings', err);
        return null;
      }
    }

    function applySavedConfig(targetConfig, savedConfig, whiteKeys) {
      if (!savedConfig) return;
      PERSISTED_FIELDS.forEach(k => {
        if (savedConfig[k] !== undefined) {
          targetConfig[k] = savedConfig[k];
        }
      });
      if (savedConfig.numHarmonics !== undefined) {
        targetConfig.numHarmonics = clamp(parseInt(savedConfig.numHarmonics, 10) || 1, 1, 8);
      }
      if (Array.isArray(savedConfig.harmonics)) {
        targetConfig.harmonics = savedConfig.harmonics.slice(0, 8);
        while (targetConfig.harmonics.length < 8) {
          targetConfig.harmonics.push(0);
        }
      }
      if (whiteKeys && !whiteKeys.includes(targetConfig.rootKey)) {
        targetConfig.rootKey = whiteKeys[0];
      }
    }

    function serializeConfig(config) {
      const serialized = {};
      PERSISTED_FIELDS.forEach(k => {
        serialized[k] = config[k];
      });
      serialized.numHarmonics = clamp(config.numHarmonics, 1, 8);
      serialized.harmonics = config.harmonics.slice(0, 8);
      return serialized;
    }

    function saveSettings() {
      try {
        const payload = {
          instr1: serializeConfig(instr1Config),
          instr2: serializeConfig(instr2Config),
          instr3: serializeConfig(instr3Config)
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (err) {
        console.warn('Could not save settings', err);
      }
    }

    function createReverbImpulse(seconds, decay) {
      const rate = audioCtx.sampleRate;
      const length = Math.max(1, Math.floor(seconds * rate));
      const impulse = audioCtx.createBuffer(2, length, rate);
      for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const channelData = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
          const t = i / length;
          channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
        }
      }
      return impulse;
    }

    function createInstrument(config) {
      const output = audioCtx.createGain();
      output.gain.value = config.volume;
      output.connect(audioCtx.destination);

      const reverbConvolver = audioCtx.createConvolver();
      reverbConvolver.buffer = createReverbImpulse(config.reverbTime, 2.5);

      const reverbWet = audioCtx.createGain();
      const reverbDry = audioCtx.createGain();
      reverbWet.gain.value = config.reverbWet;
      reverbDry.gain.value = 1 - config.reverbWet;

      const reverbInput = audioCtx.createGain();

      reverbInput.connect(reverbDry);
      reverbInput.connect(reverbConvolver);
      reverbConvolver.connect(reverbWet);

      reverbDry.connect(output);
      reverbWet.connect(output);

      config._reverbConvolver = reverbConvolver;
      config._reverbInput = reverbInput;
      config._reverbWetNode = reverbWet;
      config._reverbDryNode = reverbDry;

      const activeVoices = new Map();

      function startNote(keyId, frequency, velocity = 1) {
        if (activeVoices.has(keyId)) return;

        const now = audioCtx.currentTime;
        const voiceOutput = audioCtx.createGain();
        voiceOutput.gain.value = 0;

        const oscGain = audioCtx.createGain();
        oscGain.gain.value = velocity;

        const baseOscs = [];
        const numHarm = config.numHarmonics;
        const harmonicGains = config.harmonics;

        for (let i = 0; i < numHarm; i++) {
          const harmonicIndex = i + 1;
          const osc = audioCtx.createOscillator();
          osc.type = config.waveform;
          osc.frequency.value = frequency * harmonicIndex;
          const g = audioCtx.createGain();
          const gainVal = harmonicGains[i] ?? 0;
          g.gain.value = gainVal;
          osc.connect(g);
          g.connect(oscGain);
          osc.start(now);
          baseOscs.push({ osc, gain: g });
        }

        // Brown-ish noise via lowpass
        const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        const noiseSource = audioCtx.createBufferSource();
        noiseSource.buffer = noiseBuffer;
        noiseSource.loop = true;

        const noiseFilter = audioCtx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.value = config.noiseCutoff || 800;

        const noiseGain = audioCtx.createGain();
        noiseGain.gain.value = config.noise;

        noiseSource.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(voiceOutput);
        noiseSource.start(now);

        oscGain.connect(voiceOutput);
        voiceOutput.connect(config._reverbInput);

        const { attack, decay, sustain } = config;
        const env = voiceOutput.gain;
        env.cancelScheduledValues(now);
        env.setValueAtTime(0, now);
        env.linearRampToValueAtTime(1, now + attack);
        env.linearRampToValueAtTime(sustain, now + attack + decay);

        activeVoices.set(keyId, {
          baseOscs,
          noiseSource,
          voiceOutput
        });
      }

      function stopNote(keyId) {
        const voice = activeVoices.get(keyId);
        if (!voice) return;
        const now = audioCtx.currentTime;
        const { release } = config;
        const env = voice.voiceOutput.gain;
        env.cancelScheduledValues(now);
        const current = env.value;
        env.setValueAtTime(current, now);
        env.linearRampToValueAtTime(0, now + release);
        const stopTime = now + release + 0.05;

        voice.baseOscs.forEach(({ osc }) => osc.stop(stopTime));
        voice.noiseSource.stop(stopTime);

        setTimeout(() => {
          voice.voiceOutput.disconnect();
        }, (release + 0.1) * 1000);

        activeVoices.delete(keyId);
      }

      function updateReverb() {
        const newBuffer = createReverbImpulse(config.reverbTime, 2.5);
        config._reverbConvolver.buffer = newBuffer;
        config._reverbWetNode.gain.value = config.reverbWet;
        config._reverbDryNode.gain.value = 1 - config.reverbWet;
      }

      function setVolume(v) {
        config.volume = v;
        output.gain.value = v;
      }

      return {
        startNote,
        stopNote,
        updateReverb,
        setVolume
      };
    }

    const instr1Config = {
      waveform: 'sine',
      attack: 0.1,
      decay: 0.1,
      sustain: 0.7,
      release: 0.4,
      numHarmonics: 3,
      harmonics: [1, 0.4, 0.2, 0, 0, 0, 0, 0],
      noise: 0.05,
      noiseCutoff: 800,
      reverbTime: 2,
      reverbWet: 0.3,
      transposeNote: 'c',
      transposeOctave: 4,
      volume: 0.3,
      rootMidiBase: 60,   // C4 when root key is rootKey1
      rootKey: 'q'
    };

    const instr2Config = {
      waveform: 'sine',
      attack: 5,
      decay: 10,
      sustain: 0.7,
      release: 0.4,
      numHarmonics: 5,
      harmonics: [1, 0.7, 0.2, 0.3, 0.2, 0, 0, 0], // H3 = 0.2
      noise: 0.1,
      noiseCutoff: 400,
      reverbTime: 2.5,
      reverbWet: 0.4,
      transposeNote: 'c',
      transposeOctave: 3,
      volume: 0.3,
      rootMidiBase: 48,   // C3 when root key is rootKey2
      rootKey: 'z'
    };

    // MIDI instrument config (not persisted yet)
    const instr3Config = {
      waveform: 'sine',
      attack: 0.03,
      decay: 0.2,
      sustain: 0.9,
      release: 0.5,
      numHarmonics: 4,
      harmonics: [1, 0.7, 0.4, 0.2, 0, 0, 0, 0],
      noise: 0.02,
      noiseCutoff: 1200,
      reverbTime: 2.2,
      reverbWet: 0.35,
      transposeNote: 'c',
      transposeOctave: 4,
      volume: 0.3,
      rootMidiBase: 60,
      rootKey: 'midi'
    };

    const savedSettings = loadSettings();
    applySavedConfig(instr1Config, savedSettings?.instr1, whiteKeys1);
    applySavedConfig(instr2Config, savedSettings?.instr2, whiteKeys2);
    applySavedConfig(instr3Config, savedSettings?.instr3, null); // no persistence for MIDI instr

    const instrument1 = createInstrument(instr1Config);
    const instrument2 = createInstrument(instr2Config);
    const instrument3 = createInstrument(instr3Config);

    function buildHarmonicSliders(container, config) {
      container.innerHTML = '';
      for (let i = 0; i < config.numHarmonics; i++) {
        const row = document.createElement('div');
        row.className = 'harmonic-row';

        const label = document.createElement('div');
        label.textContent = `H${i + 1}`;
        row.appendChild(label);

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '1';
        slider.step = '0.01';
        slider.value = config.harmonics[i] ?? 0;
        slider.addEventListener('input', () => {
          config.harmonics[i] = parseFloat(slider.value);
          saveSettings();
        });
        row.appendChild(slider);

        container.appendChild(row);
      }
    }

    buildHarmonicSliders(document.getElementById('harmonics1'), instr1Config);
    buildHarmonicSliders(document.getElementById('harmonics2'), instr2Config);
    buildHarmonicSliders(document.getElementById('harmonics3'), instr3Config);

    // Populate root key selects with white keys only
    function populateRootSelect(selectEl, whiteKeys, defaultKey) {
      whiteKeys.forEach(k => {
        const opt = document.createElement('option');
        opt.value = k;
        opt.textContent = k.toUpperCase();
        if (k === defaultKey) opt.selected = true;
        selectEl.appendChild(opt);
      });
    }

    populateRootSelect(document.getElementById('rootKey1'), whiteKeys1, instr1Config.rootKey);
    populateRootSelect(document.getElementById('rootKey2'), whiteKeys2, instr2Config.rootKey);

    const TRANSPOSE_NOTES = [
      { value: 'c', label: 'C' },
      { value: 'c#', label: 'C#/Db' },
      { value: 'd', label: 'D' },
      { value: 'd#', label: 'D#/Eb' },
      { value: 'e', label: 'E' },
      { value: 'f', label: 'F' },
      { value: 'f#', label: 'F#/Gb' },
      { value: 'g', label: 'G' },
      { value: 'g#', label: 'G#/Ab' },
      { value: 'a', label: 'A' },
      { value: 'a#', label: 'A#/Bb' },
      { value: 'b', label: 'B' }
    ];

    function populateTransposeControls(noteSelect, octaveSelect, config) {
      TRANSPOSE_NOTES.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.value;
        opt.textContent = n.label;
        if (n.value === config.transposeNote) opt.selected = true;
        noteSelect.appendChild(opt);
      });

      for (let o = 0; o <= 10; o++) {
        const opt = document.createElement('option');
        opt.value = String(o);
        opt.textContent = o;
        if (o === config.transposeOctave) opt.selected = true;
        octaveSelect.appendChild(opt);
      }
    }

    function noteOctaveToMidi(note, octave) {
      const semitoneMap = {
        c: 0,
        'c#': 1,
        d: 2,
        'd#': 3,
        e: 4,
        f: 5,
        'f#': 6,
        g: 7,
        'g#': 8,
        a: 9,
        'a#': 10,
        b: 11
      };
      const semis = semitoneMap[note] ?? 0;
      return (octave + 1) * 12 + semis;
    }

    function syncControlsFromConfig(instrNum, config) {
      document.getElementById(`waveform${instrNum}`).value = config.waveform;
      document.getElementById(`attack${instrNum}`).value = config.attack;
      document.getElementById(`decay${instrNum}`).value = config.decay;
      document.getElementById(`sustain${instrNum}`).value = config.sustain;
      document.getElementById(`release${instrNum}`).value = config.release;
      document.getElementById(`numHarmonics${instrNum}`).value = config.numHarmonics;
      document.getElementById(`noise${instrNum}`).value = config.noise;
      document.getElementById(`noisePitch${instrNum}`).value = config.noiseCutoff;
      document.getElementById(`reverbTime${instrNum}`).value = config.reverbTime;
      document.getElementById(`reverbWet${instrNum}`).value = config.reverbWet;
      document.getElementById(`transposeNote${instrNum}`).value = config.transposeNote;
      document.getElementById(`transposeOctave${instrNum}`).value = config.transposeOctave;
      document.getElementById(`volume${instrNum}`).value = config.volume;
      document.getElementById(`rootKey${instrNum}`).value = config.rootKey;
    }

    // Recompute pitches & labels for a board
    function updateBoardVisuals(boardSeq, whiteKeys, whiteSet, config, instrNum) {
      const rootIdx = whiteKeys.indexOf(config.rootKey);
      const rootMidi = noteOctaveToMidi(config.transposeNote, config.transposeOctave);

      // Ionian offsets for white keys
      const whiteOffsets = {};
      whiteKeys.forEach((k, idx) => {
        whiteOffsets[k] = ionianOffset(idx - rootIdx);
      });

      boardSeq.forEach((key, idx) => {
        let offset;
        if (whiteSet.has(key)) {
          offset = whiteOffsets[key];
        } else {
          // black-ish key: place it chromatically between nearest whites
          let leftSem = null, rightSem = null;
          for (let j = idx - 1; j >= 0; j--) {
            const k2 = boardSeq[j];
            if (whiteSet.has(k2)) {
              leftSem = whiteOffsets[k2];
              break;
            }
          }
          for (let j = idx + 1; j < boardSeq.length; j++) {
            const k2 = boardSeq[j];
            if (whiteSet.has(k2)) {
              rightSem = whiteOffsets[k2];
              break;
            }
          }

          if (leftSem === null && rightSem === null) {
            offset = 0;
          } else if (rightSem === null) {
            offset = leftSem + 1;
          } else if (leftSem === null) {
            offset = rightSem - 1;
          } else {
            if (rightSem - leftSem >= 2) {
              offset = leftSem + 1; // true chromatic between
            } else {
              offset = leftSem + 1; // cluster if no gap
            }
          }
        }

        const midi = rootMidi + offset;
        keyMidi[`${instrNum}:${key}`] = midi;
        const noteName = midiToName(midi);

        const semitoneFromRoot = ((midi - rootMidi) % 12 + 12) % 12;
        const isScaleNote = IONIAN_SET.has(semitoneFromRoot);

        document.querySelectorAll(`.key[data-key="${key.replaceAll('\\','\\\\')}"]`).forEach(el => {
          el.classList.remove('white-key', 'black-key');
          el.classList.add(whiteSet.has(key) ? 'white-key' : 'black-key');
          const label = el.dataset.label || key.toUpperCase();
          el.innerHTML = `<div class="key-label">${label}</div><div class="key-note">${noteName}</div>`;

          // For black keys: hide duplicates of scale (only show non-scale accidentals)
          if (!whiteSet.has(key) && isScaleNote) {
            el.style.visibility = 'hidden';
            el.style.pointerEvents = 'none';
          } else {
            el.style.visibility = 'visible';
            el.style.pointerEvents = 'auto';
          }
        });
      });
    }

    function updateKeyVisuals() {
      updateBoardVisuals(board1Seq, whiteKeys1, whiteSet1, instr1Config, 1);
      updateBoardVisuals(board2Seq, whiteKeys2, whiteSet2, instr2Config, 2);
    }

    // Controls for instrument 1
    document.getElementById('waveform1').addEventListener('change', e => {
      instr1Config.waveform = e.target.value;
      saveSettings();
    });
    document.getElementById('attack1').addEventListener('input', e => {
      instr1Config.attack = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('decay1').addEventListener('input', e => {
      instr1Config.decay = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('sustain1').addEventListener('input', e => {
      instr1Config.sustain = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('release1').addEventListener('input', e => {
      instr1Config.release = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('numHarmonics1').addEventListener('input', e => {
      instr1Config.numHarmonics = parseInt(e.target.value, 10);
      buildHarmonicSliders(document.getElementById('harmonics1'), instr1Config);
      saveSettings();
    });
    document.getElementById('noise1').addEventListener('input', e => {
      instr1Config.noise = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('noisePitch1').addEventListener('input', e => {
      instr1Config.noiseCutoff = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('reverbTime1').addEventListener('input', e => {
      instr1Config.reverbTime = parseFloat(e.target.value);
      instrument1.updateReverb();
      saveSettings();
    });
    document.getElementById('reverbWet1').addEventListener('input', e => {
      instr1Config.reverbWet = parseFloat(e.target.value);
      instrument1.updateReverb();
      saveSettings();
    });
    populateTransposeControls(
      document.getElementById('transposeNote1'),
      document.getElementById('transposeOctave1'),
      instr1Config
    );
    syncControlsFromConfig(1, instr1Config);
    document.getElementById('transposeNote1').addEventListener('change', e => {
      instr1Config.transposeNote = e.target.value;
      updateKeyVisuals();
      saveSettings();
    });
    document.getElementById('transposeOctave1').addEventListener('change', e => {
      instr1Config.transposeOctave = parseInt(e.target.value, 10);
      updateKeyVisuals();
      saveSettings();
    });
    document.getElementById('volume1').addEventListener('input', e => {
      instrument1.setVolume(parseFloat(e.target.value));
      saveSettings();
    });
    document.getElementById('rootKey1').addEventListener('change', e => {
      instr1Config.rootKey = e.target.value;
      updateKeyVisuals();
      saveSettings();
    });

    // Controls for instrument 2
    document.getElementById('waveform2').addEventListener('change', e => {
      instr2Config.waveform = e.target.value;
      saveSettings();
    });
    document.getElementById('attack2').addEventListener('input', e => {
      instr2Config.attack = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('decay2').addEventListener('input', e => {
      instr2Config.decay = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('sustain2').addEventListener('input', e => {
      instr2Config.sustain = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('release2').addEventListener('input', e => {
      instr2Config.release = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('numHarmonics2').addEventListener('input', e => {
      instr2Config.numHarmonics = parseInt(e.target.value, 10);
      buildHarmonicSliders(document.getElementById('harmonics2'), instr2Config);
      saveSettings();
    });
    document.getElementById('noise2').addEventListener('input', e => {
      instr2Config.noise = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('noisePitch2').addEventListener('input', e => {
      instr2Config.noiseCutoff = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('reverbTime2').addEventListener('input', e => {
      instr2Config.reverbTime = parseFloat(e.target.value);
      instrument2.updateReverb();
      saveSettings();
    });
    document.getElementById('reverbWet2').addEventListener('input', e => {
      instr2Config.reverbWet = parseFloat(e.target.value);
      instrument2.updateReverb();
      saveSettings();
    });
    populateTransposeControls(
      document.getElementById('transposeNote2'),
      document.getElementById('transposeOctave2'),
      instr2Config
    );
    syncControlsFromConfig(2, instr2Config);
    document.getElementById('transposeNote2').addEventListener('change', e => {
      instr2Config.transposeNote = e.target.value;
      updateKeyVisuals();
      saveSettings();
    });
    document.getElementById('transposeOctave2').addEventListener('change', e => {
      instr2Config.transposeOctave = parseInt(e.target.value, 10);
      updateKeyVisuals();
      saveSettings();
    });
    document.getElementById('volume2').addEventListener('input', e => {
      instrument2.setVolume(parseFloat(e.target.value));
      saveSettings();
    });
    document.getElementById('rootKey2').addEventListener('change', e => {
      instr2Config.rootKey = e.target.value;
      updateKeyVisuals();
      saveSettings();
    });
    saveSettings();

    // Controls for instrument 3 (MIDI)
    document.getElementById('waveform3').addEventListener('change', e => {
      instr3Config.waveform = e.target.value;
      saveSettings();
    });
    document.getElementById('attack3').addEventListener('input', e => {
      instr3Config.attack = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('decay3').addEventListener('input', e => {
      instr3Config.decay = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('sustain3').addEventListener('input', e => {
      instr3Config.sustain = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('release3').addEventListener('input', e => {
      instr3Config.release = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('numHarmonics3').addEventListener('input', e => {
      instr3Config.numHarmonics = parseInt(e.target.value, 10);
      buildHarmonicSliders(document.getElementById('harmonics3'), instr3Config);
      saveSettings();
    });
    document.getElementById('noise3').addEventListener('input', e => {
      instr3Config.noise = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('noisePitch3').addEventListener('input', e => {
      instr3Config.noiseCutoff = parseFloat(e.target.value);
      saveSettings();
    });
    document.getElementById('reverbTime3').addEventListener('input', e => {
      instr3Config.reverbTime = parseFloat(e.target.value);
      saveSettings();
      instrument3.updateReverb();
    });
    document.getElementById('reverbWet3').addEventListener('input', e => {
      instr3Config.reverbWet = parseFloat(e.target.value);
      saveSettings();
      instrument3.updateReverb();
    });
    document.getElementById('volume3').addEventListener('input', e => {
      instrument3.setVolume(parseFloat(e.target.value));
      saveSettings();
    });

    // Map from physical key to instrument
    const keyMap = {};
    board1Seq.forEach(k => { keyMap[k] = { instr: 1 }; });
    board2Seq.forEach(k => { keyMap[k] = { instr: 2 }; });

    function getFrequencyForKey(instrNum, key) {
      const midi = keyMidi[`${instrNum}:${key}`];
      return midiToFreq(midi);
    }

    const downKeys = new Set();

    function setVisualKeyActive(key, active) {
      document.querySelectorAll(`.key[data-key="${key.replaceAll('\\','\\\\')}"]`).forEach(el => {
        el.classList.toggle('active', active);
      });
    }

    window.addEventListener('keydown', e => {
      let key = e.key;
      if (key === 'Tab') {
        e.preventDefault();
        key = 'tab';
      } else {
        key = key.toLowerCase();
      }

      const mapping = keyMap[key];
      if (!mapping) return;
      if (e.repeat) return;

      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      const freq = getFrequencyForKey(mapping.instr, key);
      const instr = mapping.instr === 1 ? instrument1 : instrument2;
      const voiceId = `${mapping.instr}:${key}`;
      downKeys.add(voiceId);
      instr.startNote(voiceId, freq);
      setVisualKeyActive(key, true);
    });

    window.addEventListener('keyup', e => {
      let key = e.key === 'Tab' ? 'tab' : e.key.toLowerCase();
      const mapping = keyMap[key];
      if (!mapping) return;

      const voiceId = `${mapping.instr}:${key}`;
      if (!downKeys.has(voiceId)) return;
      const instr = mapping.instr === 1 ? instrument1 : instrument2;
      instr.stopNote(voiceId);
      downKeys.delete(voiceId);
      setVisualKeyActive(key, false);
    });

    // Mouse support
    document.querySelectorAll('.key').forEach(el => {
      el.addEventListener('mousedown', () => {
        const key = el.dataset.key;
        const mapping = keyMap[key];
        if (!mapping) return;

        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }

        const freq = getFrequencyForKey(mapping.instr, key);
        const instr = mapping.instr === 1 ? instrument1 : instrument2;
        const voiceId = `${mapping.instr}:${key}`;
        if (!downKeys.has(voiceId)) {
          downKeys.add(voiceId);
          instr.startNote(voiceId, freq);
          setVisualKeyActive(key, true);
        }
      });

      const stopForEl = () => {
        const key = el.dataset.key;
        const mapping = keyMap[key];
        if (!mapping) return;
        const voiceId = `${mapping.instr}:${key}`;
        if (!downKeys.has(voiceId)) return;
        const instr = mapping.instr === 1 ? instrument1 : instrument2;
        instr.stopNote(voiceId);
        downKeys.delete(voiceId);
        setVisualKeyActive(key, false);
      };

      el.addEventListener('mouseup', stopForEl);
      el.addEventListener('mouseleave', stopForEl);
    });

    // === MIDI support ===

    let midiAccess = null;
    const midiKeyboards = [];

    function logMidiEvent(kb, evt, type, channel, data1, data2) {
      const el = kb.logEl;
      const time = evt.timeStamp.toFixed(1);
      let desc = `0x${evt.data[0].toString(16).padStart(2, '0')},${evt.data[1].toString().padStart(3, '0')},${evt.data[2].toString().padStart(3, '0')} – `;
      if (type === 0x90) {
        desc += `Note on ch${channel} n=${data1} v=${data2} (${midiToName(data1)})`;
      } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
        desc += `Note off ch${channel} n=${data1} (${midiToName(data1)})`;
      } else if (type === 0xB0) {
        desc += `CC ch${channel} cc=${data1} v=${data2}`;
      } else {
        desc += `0x${type.toString(16)} ch${channel} d1=${data1} d2=${data2}`;
      }
      const line = document.createElement('div');
      line.textContent = `${time}ms – ${desc}`;
      el.prepend(line);
      while (el.childElementCount > 100) {
        el.removeChild(el.lastChild);
      }
    }

    function handleMIDIMessageForKeyboard(evt, kb) {
      const [status, data1, data2] = evt.data;
      const type = status & 0xf0;
      const channel = (status & 0x0f) + 1;

      // Channel filter: 0 = all
      if (kb.channel && channel !== kb.channel) return;

      logMidiEvent(kb, evt, type, channel, data1, data2);

      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }

      // volume control (CC1)
      if (type === 0xB0 && data1 === 1) {
        const vol = data2 / 127;
        instrument3.setVolume(vol);
      }

      // Note on/off
      if (type === 0x90 && data2 > 0) {
        const midiNote = data1;
        const freq = midiToFreq(midiNote);
        const voiceId = `midi:${kb.input?.id || 'input'}:${midiNote}`;
        const GAMMA = 1.5;
        kb.instrument.startNote(voiceId, freq, (data2 / 127) ** GAMMA);
      } else if (type === 0x80 || (type === 0x90 && data2 === 0)) {
        const midiNote = data1;
        const voiceId = `midi:${kb.input?.id || 'input'}:${midiNote}`;
        kb.instrument.stopNote(voiceId);
      }
    }

    function refreshInputsForKeyboard(kb) {
      const select = kb.inputSelect;
      if (!midiAccess) {
        kb.statusEl.textContent = 'No MIDI access yet.';
        select.innerHTML = '';
        return;
      }

      const inputs = Array.from(midiAccess.inputs.values());
      select.innerHTML = '';

      if (inputs.length === 0) {
        const opt = document.createElement('option');
        opt.textContent = 'No MIDI inputs';
        opt.value = '';
        select.appendChild(opt);
        kb.statusEl.textContent = 'No MIDI inputs connected.';
        kb.input = null;
        return;
      }

      const previousId = kb.input?.id || '';
      let selectedInput = null;

      inputs.forEach((input, idx) => {
        const opt = document.createElement('option');
        opt.value = input.id;
        opt.textContent = input.name || `Input ${idx + 1}`;
        if (input.id === previousId || (!previousId && idx === 0)) {
          opt.selected = true;
          selectedInput = input;
        }
        select.appendChild(opt);
      });

      if (!selectedInput) selectedInput = inputs[0];

      kb.input = selectedInput;
      if (kb.input) {
        kb.input.onmidimessage = evt => handleMIDIMessageForKeyboard(evt, kb);
        kb.statusEl.textContent = `Connected to ${kb.input.name || kb.input.id}`;
      } else {
        kb.statusEl.textContent = 'No MIDI input selected.';
      }
    }

    function refreshMidiInputs() {
      midiKeyboards.forEach(kb => refreshInputsForKeyboard(kb));
    }

    function createMidiKeyboard(options) {
      const kb = {
        instrument: options.instrument,
        inputSelect: document.getElementById(options.inputSelectId),
        channelSelect: document.getElementById(options.channelSelectId),
        statusEl: document.getElementById(options.statusId),
        logEl: document.getElementById(options.logId),
        input: null,
        channel: 0 // 0 = all
      };

      // Populate channel select: 0 (All), 1–16
      kb.channelSelect.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = '0';
      optAll.textContent = 'All';
      kb.channelSelect.appendChild(optAll);
      for (let ch = 1; ch <= 16; ch++) {
        const opt = document.createElement('option');
        opt.value = String(ch);
        opt.textContent = String(ch);
        kb.channelSelect.appendChild(opt);
      }
      kb.channelSelect.value = '0';
      kb.channelSelect.addEventListener('change', () => {
        kb.channel = parseInt(kb.channelSelect.value, 10) || 0;
      });

      kb.inputSelect.addEventListener('change', () => {
        if (!midiAccess) return;
        const targetId = kb.inputSelect.value;
        const input = Array.from(midiAccess.inputs.values()).find(i => i.id === targetId);
        if (input) {
          kb.input = input;
          kb.input.onmidimessage = evt => handleMIDIMessageForKeyboard(evt, kb);
          kb.statusEl.textContent = `Connected to ${kb.input.name || kb.input.id}`;
        } else {
          kb.statusEl.textContent = 'No MIDI input selected.';
        }
      });

      midiKeyboards.push(kb);
      return kb;
    }

    function initMIDI() {
      const status3 = document.getElementById('midiStatus3');
      if (!navigator.requestMIDIAccess) {
        status3.textContent = 'This browser does not support Web MIDI.';
        return;
      }
      navigator.requestMIDIAccess().then(access => {
        midiAccess = access;
        status3.textContent = 'MIDI ready.';
        refreshMidiInputs();
        midiAccess.onstatechange = () => {
          refreshMidiInputs();
        };
      }, err => {
        status3.textContent = 'Could not access MIDI: ' + err;
      });
    }

    // Initial mapping and labels
    updateKeyVisuals();

    // Create MIDI keyboard wrapper for instrument 3
    createMidiKeyboard({
      instrument: instrument3,
      inputSelectId: 'midiInputSelect3',
      channelSelectId: 'midiChannel3',
      statusId: 'midiStatus3',
      logId: 'midiLog3'
    });

    initMIDI();
  </script>
</body>
</html>
