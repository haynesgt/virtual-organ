<!DOCTYPE html>
<html lang="en-US">
<!-- Simple index.html with in-browser jsx compilation -->
<head>
<title>App</title>
<script src="https://unpkg.com/lodash@4.17.21" crossorigin></script>
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-bootstrap@1.5.2/dist/react-bootstrap.js" crossorigin></script>
<script src="https://unpkg.com/react-router-dom@5.2.0/umd/react-router-dom.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone@7.20.12/babel.js"></script>
<!-- Useful things
https://github.com/johndiiorio/react-useinterval/blob/master/src/index.tsx
https://github.com/dance2die/react-use-localstorage/blob/master/src/index.ts
-->
<!-- no 404 request for icon 
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">-->
<link href="https://getbootstrap.com/docs/4.6/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<style>
</style>
</head>
<body>
<div id="app"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;
const { HashRouter, Link, Route, useRouteMatch } = ReactRouterDOM;
const { Dropdown } = ReactBootstrap;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function createReverbImpulse(seconds, decay) {
    const rate = audioCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * rate));
    const impulse = audioCtx.createBuffer(2, length, rate);
    for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const channelData = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
        }
    }
    return impulse;
}

function createCompressor() {
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;  // Start compressing at -24dB
    compressor.knee.value = 30;        // Smooth compression curve
    compressor.ratio.value = 12;       // Strong compression (12:1)
    compressor.attack.value = 0.01;   // Fast attack (3ms)
    compressor.release.value = 0.25;   // Medium release (250ms)
    return compressor;
}

const compressor = createCompressor();
compressor.connect(audioCtx.destination);

function createInstrumentRootNode(config) {
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = config.volume || 1.0;

    const dryGain = audioCtx.createGain();
    dryGain.gain.value = config.dryMix || 0.9;
    dryGain.connect(masterGain);

    const wetGain = audioCtx.createGain();
    wetGain.gain.value = config.wetMix || 0.2;
    wetGain.connect(masterGain);

    const reverbNode = audioCtx.createGain();
    reverbNode.connect(wetGain);

    const convolver = audioCtx.createConvolver();
    convolver.buffer = createReverbImpulse(config.reverb.seconds || 3, config.reverb.decay || 2);
    reverbNode.connect(convolver);
    convolver.connect(wetGain);

    return { masterGain, dryGain, wetGain, reverbNode, convolver };
}

class NoteInstrument {
    constructor() {
        this.rootNode = createInstrumentRootNode({
            volume: 0.7,
            dryMix: 0.8,
            wetMix: 0.3,
            reverb: { seconds: 2, decay: 2 }
        });
        this.rootNode.masterGain.connect(compressor);
        this.noteOscs = {};
        this.envelope = {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.7,
            release: 0.5
        };
    }

    setAttack(value) {
        this.envelope.attack = value;
    }

    setDecay(value) {
        this.envelope.decay = value;
    }

    setSustain(value) {
        this.envelope.sustain = value;
    }

    setRelease(value) {
        this.envelope.release = value;
    }

    setVolume(value) {
        this.rootNode.masterGain.gain.setValueAtTime(value, audioCtx.currentTime);
    }

    setReverbMix(value) {
        this.rootNode.wetGain.gain.setValueAtTime(value, audioCtx.currentTime);
        this.rootNode.dryGain.gain.setValueAtTime(1.0 - value, audioCtx.currentTime);
    }

    setReverbTime(seconds, decay) {
        const convolver = this.rootNode.convolver;
        convolver.buffer = createReverbImpulse(seconds, decay);
    }

    startNote(note, velocity = 1.0) {
        const noteFrequency = 440 * Math.pow(2, (note - 69) / 12);
        const noteWavelength = 1 / noteFrequency;
        const attack = Math.max(this.envelope.attack, noteWavelength);
        if (this.noteOscs[note]) {
            const existing = this.noteOscs[note];
            existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, audioCtx.currentTime);
            existing.gainNode.gain.linearRampToValueAtTime(velocity, audioCtx.currentTime + attack);
            existing.gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, audioCtx.currentTime + attack + this.envelope.decay);
            return;
        }
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.type = 'sine';
        osc.setPeriodicWave(audioCtx.createPeriodicWave(
            new Float32Array([0, 0, 0, 0, 0]),
            new Float32Array([1, 0.5, 0.25, 0.125, 0.0625])
        ));
        osc.frequency.value = noteFrequency;

        const now = audioCtx.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(velocity, now + attack);
        gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, now + attack + this.envelope.decay);

        osc.connect(gainNode);
        gainNode.connect(this.rootNode.dryGain);
        gainNode.connect(this.rootNode.reverbNode);

        osc.start();
        this.noteOscs[note] = { osc, gainNode };
    }

    stopNote(note) {
        const existing = this.noteOscs[note];
        if (existing) {
            const now = audioCtx.currentTime;
            existing.gainNode.gain.cancelScheduledValues(now);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, now);
            existing.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
            setTimeout(() => {
                if (existing.gainNode.gain === 0) {
                    existing.osc.stop();
                    existing.osc.disconnect();
                    existing.gainNode.disconnect();
                }
            }, this.envelope.release * 1000 + 100);
        }
    }
}

const app = document.getElementById("app");

const instrument = new NoteInstrument();

function App() {
    const [isAudioOn, setIsAudioOn] = useState(audioCtx.state === "running");
    const [attack, setAttack] = useState(() => parseFloat(localStorage.getItem('attack')) || 0.01);
    const [decay, setDecay] = useState(() => parseFloat(localStorage.getItem('decay')) || 0.2);
    const [sustain, setSustain] = useState(() => parseFloat(localStorage.getItem('sustain')) || 0.7);
    const [release, setRelease] = useState(() => parseFloat(localStorage.getItem('release')) || 0.5);
    const [volume, setVolume] = useState(() => parseFloat(localStorage.getItem('volume')) || 0.7);
    const [reverbMix, setReverbMix] = useState(() => parseFloat(localStorage.getItem('reverbMix')) || 0.3);
    const [reverbTime, setReverbTime] = useState(() => parseFloat(localStorage.getItem('reverbTime')) || 2);
    const [reverbDecay, setReverbDecay] = useState(() => parseFloat(localStorage.getItem('reverbDecay')) || 2);
    const [midiAccess, setMidiAccess] = useState(null);
    const [midiInputs, setMidiInputs] = useState([]);
    const [selectedInputIds, setSelectedInputIds] = useState(() => JSON.parse(localStorage.getItem('selectedInputIds')) || []);
    const [midiStatus, setMidiStatus] = useState("MIDI not enabled");
    const activeInputsRef = useRef(new Map());

  const updateMidiInputs = (access) => {
      const inputs = Array.from(access.inputs.values()).map((input) => ({
          id: input.id,
          name: input.name || "Unknown device",
          manufacturer: input.manufacturer || "Unknown manufacturer"
      }));
      setMidiInputs(inputs);
      if (inputs.length === 0) {
          setMidiStatus("No MIDI inputs found");
      } else {
          setMidiStatus(`${inputs.length} MIDI input${inputs.length === 1 ? "" : "s"} available`);
      }
  };

  const handleEnableMidi = async () => {
      if (!navigator.requestMIDIAccess) {
          setMidiStatus("Web MIDI not supported in this browser");
          return;
      }
      try {
          const access = await navigator.requestMIDIAccess();
          setMidiAccess(access);
          updateMidiInputs(access);
          access.onstatechange = () => updateMidiInputs(access);
      } catch (err) {
          setMidiStatus("MIDI access denied");
      }
  };

  const handleMidiMessage = async (event) => {
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
          setIsAudioOn(true);
      }
      const [status, note, velocity] = event.data;
      const command = status & 0xf0;
      if (command === 0x90 && velocity > 0) {
          instrument.startNote(note, velocity / 127);
      } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
          instrument.stopNote(note);
      }
  };

  const connectSelectedInputs = (ids) => {
      if (!midiAccess) {
          return;
      }
      const activeInputs = activeInputsRef.current;
      const nextIds = new Set(ids);

      for (const [id, input] of activeInputs.entries()) {
          if (!nextIds.has(id)) {
              input.onmidimessage = null;
              activeInputs.delete(id);
          }
      }

      ids.forEach((id) => {
          if (!activeInputs.has(id)) {
              const input = midiAccess.inputs.get(id);
              if (input) {
                  input.onmidimessage = handleMidiMessage;
                  activeInputs.set(id, input);
              }
          }
      });

      if (ids.length === 0) {
          setMidiStatus(midiInputs.length > 0 ? "No MIDI inputs selected" : "No MIDI inputs found");
      } else {
          setMidiStatus(`Connected to ${ids.length} input${ids.length === 1 ? "" : "s"}`);
      }
  };

  const handleMidiSelection = (e) => {
      const options = Array.from(e.target.selectedOptions);
      const ids = options.map((option) => option.value);
      setSelectedInputIds(ids);
      connectSelectedInputs(ids);
  };

  useEffect(() => {
      return () => {
          const activeInputs = activeInputsRef.current;
          for (const input of activeInputs.values()) {
              input.onmidimessage = null;
          }
          activeInputs.clear();
      };
  }, []);

    useEffect(() => {
        handleEnableMidi();
    }, []);

  useEffect(() => {
      localStorage.setItem('attack', attack);
      instrument.setAttack(attack);
  }, [attack]);

  useEffect(() => {
      localStorage.setItem('decay', decay);
      instrument.setDecay(decay);
  }, [decay]);

  useEffect(() => {
      localStorage.setItem('sustain', sustain);
      instrument.setSustain(sustain);
  }, [sustain]);

  useEffect(() => {
      localStorage.setItem('release', release);
      instrument.setRelease(release);
  }, [release]);

  useEffect(() => {
      localStorage.setItem('volume', volume);
      instrument.setVolume(volume);
  }, [volume]);

  useEffect(() => {
      localStorage.setItem('reverbMix', reverbMix);
      instrument.setReverbMix(reverbMix);
  }, [reverbMix]);

  useEffect(() => {
      localStorage.setItem('reverbTime', reverbTime);
      instrument.setReverbTime(reverbTime, reverbDecay);
  }, [reverbTime, reverbDecay]);

  useEffect(() => {
      localStorage.setItem('selectedInputIds', JSON.stringify(selectedInputIds));
  }, [selectedInputIds]);

  const handleAttack = (e) => setAttack(Number(e.target.value));
  const handleDecay = (e) => setDecay(Number(e.target.value));
  const handleSustain = (e) => setSustain(Number(e.target.value));
  const handleRelease = (e) => setRelease(Number(e.target.value));
  const handleVolume = (e) => setVolume(Number(e.target.value));
  const handleReverbMix = (e) => setReverbMix(Number(e.target.value));
  const handleReverbTime = (e) => setReverbTime(Number(e.target.value));
  const handleReverbDecay = (e) => setReverbDecay(Number(e.target.value));

  return (
    <div className="container py-4">
        <div className="d-flex align-items-center justify-content-between mb-3">
            <h1 className="h3 mb-0">React Audio Instrument</h1>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <div className="form-group mb-3">
                    <div className="d-flex align-items-center justify-content-between">
                        <label className="form-label mb-0">MIDI Inputs</label>
                        <button className="btn btn-outline-secondary btn-sm" onClick={handleEnableMidi}>
                            {midiAccess ? "Refresh MIDI" : "Enable MIDI"}
                        </button>
                    </div>
                    <small className="text-muted d-block mb-2">{midiStatus}</small>
                    <select
                        className="form-control"
                        multiple
                        value={selectedInputIds}
                        onChange={handleMidiSelection}
                        disabled={!midiAccess || midiInputs.length === 0}
                    >
                        {midiInputs.length === 0 && <option value="">No MIDI devices</option>}
                        {midiInputs.map((input) => (
                            <option key={input.id} value={input.id}>
                                {input.manufacturer} {input.name}
                            </option>
                        ))}
                    </select>
                </div>

                <div className="row">
                    <div className="col-md-6">
                        <h2 className="h5">Envelope</h2>
                        <div className="form-group mb-3">
                            <label className="form-label">Attack: {attack.toFixed(3)}s</label>
                            <input type="range" min="0.001" max="1" step="0.001" value={attack} onChange={handleAttack} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Decay: {decay.toFixed(3)}s</label>
                            <input type="range" min="0.001" max="2" step="0.001" value={decay} onChange={handleDecay} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Sustain: {sustain.toFixed(2)}</label>
                            <input type="range" min="0" max="1" step="0.01" value={sustain} onChange={handleSustain} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Release: {release.toFixed(3)}s</label>
                            <input type="range" min="0.001" max="2" step="0.001" value={release} onChange={handleRelease} className="form-control-range" />
                        </div>
                    </div>
                    <div className="col-md-6">
                        <h2 className="h5">Output</h2>
                        <div className="form-group mb-3">
                            <label className="form-label">Volume: {volume.toFixed(2)}</label>
                            <input type="range" min="0" max="1" step="0.01" value={volume} onChange={handleVolume} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Reverb Mix: {reverbMix.toFixed(2)}</label>
                            <input type="range" min="0" max="1" step="0.01" value={reverbMix} onChange={handleReverbMix} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Reverb Time: {reverbTime.toFixed(2)}s</label>
                            <input type="range" min="0.1" max="6" step="0.1" value={reverbTime} onChange={handleReverbTime} className="form-control-range" />
                        </div>
                        <div className="form-group mb-3">
                            <label className="form-label">Reverb Decay: {reverbDecay.toFixed(2)}</label>
                            <input type="range" min="0.5" max="6" step="0.1" value={reverbDecay} onChange={handleReverbDecay} className="form-control-range" />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  )
}
ReactDOM.render(React.createElement(App), document.getElementById("app"))
</script>
</body>
</html>
