f<!DOCTYPE html>
<html lang="en-US">
<!-- Simple index.html with in-browser jsx compilation -->
<head>
<title>Synth</title>
<script src="https://unpkg.com/lodash@4.17.21" crossorigin></script>
<script src="https://unpkg.com/@tonejs/midi@2.0.27" crossorigin></script>
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-bootstrap@1.5.2/dist/react-bootstrap.js" crossorigin></script>
<script src="https://unpkg.com/react-router-dom@5.2.0/umd/react-router-dom.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone@7.20.12/babel.js"></script>
<!-- Useful things
https://github.com/johndiiorio/react-useinterval/blob/master/src/index.tsx
https://github.com/dance2die/react-use-localstorage/blob/master/src/index.ts
-->
<!-- no 404 request for icon 
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">-->
<link href="https://getbootstrap.com/docs/4.6/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<style>
</style>
</head>
<body>
<div id="app"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;
const { HashRouter, Link, Route, useRouteMatch } = ReactRouterDOM;
const { Dropdown } = ReactBootstrap;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const harmonicsCount = 20;

const notesPerOctave = 12;

function mapCcValue(val) {
    // Map 0-127 to a curve that is more sensitive at the low end for better control over subtle changes
    // makes sure both 63 and 64 map to 0.5 for controls that rest at the center
    return val < 64 ? val / 126 : ((val - 64) / 126 + 0.5);
}

// Helper hook to create state with matching ref for callback access
function useStateWithRef(initialValue) {
    const [state, setState] = useState(initialValue);
    const ref = useRef(initialValue);
    
    useEffect(() => {
        ref.current = state;
    }, [state]);
    
    return [state, setState, ref];
}

// Helper hook for localStorage-backed numeric state
function useLocalStorageNumber(key, fallbackValue) {
    const [value, setValue] = useState(() => getStoredNumber(key, fallbackValue));
    
    useEffect(() => {
        console.log(`Saving ${key} = ${value} to localStorage`);
        localStorage.setItem(key, value);
    }, [key, value]);
    
    return [value, setValue];
}

// Helper hook for localStorage-backed numeric state with ref
function useLocalStorageNumberWithRef(key, fallbackValue) {
    const [value, setValue] = useLocalStorageNumber(key, fallbackValue);
    const ref = useRef(value);
    
    const set = useCallback((newValue) => {
        setValue(prev => {
            const next = typeof newValue === "function" ? newValue(prev) : newValue;
            ref.current = next;
            return next;
        });
    }, []);
    
    
    return { get current() { return ref.current; }, set };
}

function useRangedControl(key, fallbackValue, minKey, minFallback, maxKey, maxFallback) {
    const control = useLocalStorageNumberWithRef(key, fallbackValue);
    const min = useLocalStorageNumberWithRef(minKey, minFallback);
    const max = useLocalStorageNumberWithRef(maxKey, maxFallback);

    return {
        get current() { return control.current; },
        set: control.set,
        min,
        max
    };
}

function createReverbImpulse(seconds, decay) {
    const rate = audioCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * rate));
    const impulse = audioCtx.createBuffer(2, length, rate);
    for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const channelData = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
        }
    }
    return impulse;
}

function createCompressor() {
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;  // Start compressing at -24dB
    compressor.knee.value = 30;        // Smooth compression curve
    compressor.ratio.value = 12;       // Strong compression (12:1)
    compressor.attack.value = 0.003;   // Fast attack (3ms)
    compressor.release.value = 0.5;   // Medium release (500ms)
    return compressor;
}

const compressor = createCompressor();
const recordingDestination = audioCtx.createMediaStreamDestination();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 8192; // Higher FFT size for better frequency resolution
analyser.smoothingTimeConstant = 0;
compressor.connect(recordingDestination);
compressor.connect(analyser);
analyser.connect(audioCtx.destination);

const masterBus = (() => {
    const masterGain = audioCtx.createGain();
    const dryGain = audioCtx.createGain();
    const wetGain = audioCtx.createGain();
    const reverbSend = audioCtx.createGain();
    const convolver = audioCtx.createConvolver();

    masterGain.gain.value = 0.8;
    dryGain.gain.value = 0.7;
    wetGain.gain.value = 0.3;
    reverbSend.gain.value = 1.0;
    convolver.buffer = createReverbImpulse(2, 2);

    dryGain.connect(masterGain);
    wetGain.connect(masterGain);
    reverbSend.connect(convolver);
    convolver.connect(wetGain);
    masterGain.connect(compressor);

    return { masterGain, dryGain, wetGain, reverbSend, convolver };
})();

class VoiceInstrument {
    constructor(output) {
        this.output = output;
        this.voiceGain = audioCtx.createGain();
        this.voiceGain.gain.value = 0.7;
        this.voiceGain.connect(output.dryGain);
        this.voiceGain.connect(output.reverbSend);
        this.noteOscs = {};
        this.envelope = {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.7,
            release: 0.5
        };
        this.harmonicsGamma = 0.5;
        this.evenHarmonicsScale = 1.0;
        this.pitchBend = 0; // in semitones
    }

    setAttack(value) {
        this.envelope.attack = value;
    }

    setDecay(value) {
        this.envelope.decay = value;
    }

    setSustain(value) {
        this.envelope.sustain = value;
    }

    setRelease(value) {
        this.envelope.release = value;
    }

    setVolume(value) {
        this.voiceGain.gain.cancelScheduledValues(audioCtx.currentTime);
        this.voiceGain.gain.setValueAtTime(this.voiceGain.gain.value, audioCtx.currentTime);
        this.voiceGain.gain.linearRampToValueAtTime(value ** 2, audioCtx.currentTime + 0.1);
    }

    _getPreiodicWave() {
        const gamma = this.harmonicsGamma;
        const oddScale = this.evenHarmonicsScale;
        const imag = new Float32Array(harmonicsCount);
        for (let i = 1; i < imag.length; i++) {
            const base = Math.pow(gamma, i);
            imag[i] = (i % 2 === 0) ? base * oddScale : base;
        }
        return audioCtx.createPeriodicWave(
            new Float32Array(harmonicsCount),
            imag,
        );
    }

    setHarmonicsGamma(value) {
        this.harmonicsGamma = value;
        const wave = this._getPreiodicWave();
        Object.values(this.noteOscs).forEach(({ osc }) => {
            osc.setPeriodicWave(wave);
        });
    }

    setEvenHarmonicsScale(value) {
        this.evenHarmonicsScale = value;
        const wave = this._getPreiodicWave();
        Object.values(this.noteOscs).forEach(({ osc }) => {
            osc.setPeriodicWave(wave);
        });
    }

    setPitchBend(semitones) {
        this.pitchBend = semitones;
        Object.entries(this.noteOscs).forEach(([note, { osc }]) => {
            const baseFrequency = 440 * Math.pow(2, (Number(note) - 69) / notesPerOctave);
            const bendedFrequency = baseFrequency * Math.pow(2, semitones / notesPerOctave);
            osc.frequency.setValueAtTime(bendedFrequency, audioCtx.currentTime);
        });
    }

    startNote(note, velocity = 1.0) {
        const baseFrequency = 440 * Math.pow(2, (note - 69) / notesPerOctave);
        const noteFrequency = baseFrequency * Math.pow(2, this.pitchBend / notesPerOctave);
        const noteWavelength = 1 / noteFrequency;
        const attack = Math.max(this.envelope.attack, noteWavelength) / 2;
        const existing = this.noteOscs[note];
        if (existing) {
            if (existing.gainNode.gain.value === 0) {
                existing.osc.stop();
                existing.osc.disconnect();
                existing.gainNode.disconnect();
                delete this.noteOscs[note];
            } else {
                existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, audioCtx.currentTime);
                existing.gainNode.gain.linearRampToValueAtTime(velocity, audioCtx.currentTime + attack);
                existing.gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, audioCtx.currentTime + attack + this.envelope.decay);
                return;
            }
        }
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.type = 'sine';
        const wave = this._getPreiodicWave();
        osc.setPeriodicWave(wave);
        osc.frequency.value = noteFrequency;

        const now = audioCtx.currentTime + 0.01; // slight delay to avoid clicks
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(velocity, now + attack);
        gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, now + attack + this.envelope.decay);

        osc.connect(gainNode);
        gainNode.connect(this.voiceGain);

        osc.start(now);
        this.noteOscs[note] = { osc, gainNode };
    }

    stopNote(note) {
        const existing = this.noteOscs[note];
        if (existing) {
            const now = audioCtx.currentTime;
            existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, audioCtx.currentTime);
            existing.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
            setTimeout(() => {
                if (existing.gainNode.gain.value === 0) {
                    existing.osc.stop();
                    existing.osc.disconnect();
                    existing.gainNode.disconnect();
                    if (existing === this.noteOscs[note]) {
                        delete this.noteOscs[note];
                    }
                }
            }, this.envelope.release * 1000 + 100);
        }
    }

    stopAllNotes() {
        Object.keys(this.noteOscs).forEach((note) => this.stopNote(Number(note)));
    }

    stopAllNotesImmediate() {
        Object.entries(this.noteOscs).forEach(([note, existing]) => {
            try {
                existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                existing.gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                existing.osc.stop();
            } catch (err) {
                // Ignore node stop errors during shutdown.
            }
            existing.osc.disconnect();
            existing.gainNode.disconnect();
            delete this.noteOscs[note];
        });
    }

    dispose() {
        this.stopAllNotesImmediate();
        this.voiceGain.disconnect();
    }
}

const app = document.getElementById("app");

const getStoredNumber = (key, fallbackValue) => {
    const raw = localStorage.getItem(key);
    if (raw === null || raw === undefined || raw === "") {
        return fallbackValue;
    }
    const parsed = Number(raw);
    return Number.isFinite(parsed) ? parsed : fallbackValue;
};

const createVoiceId = () => `voice-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
const createConfigId = () => `config-${Date.now()}-${Math.floor(Math.random() * 100000)}`;

const voiceValueDefaults = {
    attack: 0.01,
    attackMin: 0.001,
    attackMax: 1,
    decay: 0.2,
    decayMin: 0.001,
    decayMax: 2,
    sustain: 0.7,
    sustainMin: 0,
    sustainMax: 1,
    release: 0.5,
    releaseMin: 0.001,
    releaseMax: 2,
    volume: 0.7,
    volumeMin: 0,
    volumeMax: 1,
    harmonicsGamma: 0.5,
    harmonicsGammaMin: 0.1,
    harmonicsGammaMax: 1,
    evenHarmonicsScale: 0.5,
    evenHarmonicsScaleMin: 0,
    evenHarmonicsScaleMax: 1,
    pitchBend: 0,
    pitchBendMin: -2,
    pitchBendMax: 2,
    noteMin: 0,
    noteMinMin: 0,
    noteMinMax: 127,
    noteMax: 127,
    noteMaxMin: 0,
    noteMaxMax: 127,
    noteMinEnabled: 1,
    noteMaxEnabled: 1
};

const masterValueDefaults = {
    masterVolume: 0.8,
    masterVolumeMin: 0,
    masterVolumeMax: 1,
    reverbMix: 0.3,
    reverbMixMin: 0,
    reverbMixMax: 1,
    reverbTime: 2,
    reverbTimeMin: 0.1,
    reverbTimeMax: 6,
    reverbDecay: 2,
    reverbDecayMin: 0.5,
    reverbDecayMax: 6
};

const applyVoiceSettingsFromStorage = (voiceId, instrument) => {
    if (!instrument) {
        return;
    }
    const getValue = (key, fallback) => getStoredNumber(`${voiceId}:${key}`, fallback);
    instrument.setAttack(getValue("attack", voiceValueDefaults.attack));
    instrument.setDecay(getValue("decay", voiceValueDefaults.decay));
    instrument.setSustain(getValue("sustain", voiceValueDefaults.sustain));
    instrument.setRelease(getValue("release", voiceValueDefaults.release));
    instrument.setVolume(getValue("volume", voiceValueDefaults.volume));
    instrument.setHarmonicsGamma(getValue("harmonicsGamma", voiceValueDefaults.harmonicsGamma));
    instrument.setEvenHarmonicsScale(getValue("evenHarmonicsScale", voiceValueDefaults.evenHarmonicsScale));
    instrument.setPitchBend(getValue("pitchBend", voiceValueDefaults.pitchBend));
};

const ensureVoiceShape = (voice, index) => {
    const id = voice && voice.id ? voice.id : createVoiceId();
    return {
        id,
        name: (voice && voice.name) ? voice.name : `Voice ${index + 1}`,
        selectedInputIds: Array.isArray(voice && voice.selectedInputIds) ? voice.selectedInputIds : []
    };
};

const loadStoredVoices = () => {
    try {
        const raw = localStorage.getItem("voices");
        if (!raw) {
            return [ensureVoiceShape({}, 0)];
        }
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed) || parsed.length === 0) {
            return [ensureVoiceShape({}, 0)];
        }
        return parsed.map((voice, index) => ensureVoiceShape(voice, index));
    } catch (err) {
        return [ensureVoiceShape({}, 0)];
    }
};

const makeVoiceControlId = (voiceId, control) => `voice:${voiceId}:${control}`;
const makeMasterControlId = (control) => `master:${control}`;

function SliderControl({
    label,
    value,
    onChange,
    min,
    max,
    step,
    unit,
    decimals = 2,
    numberStep,
    inputId,
    showRangeInputs = true,
    onMinChange,
    onMaxChange,
    onMidiLearn,
    isMidiLearning,
    midiMapping,
    onMidiClear
}) {
    const [valueInput, setValueInput] = useState(value === undefined ? "" : String(value));
    const [minInput, setMinInput] = useState(min === undefined ? "" : String(min));
    const [maxInput, setMaxInput] = useState(max === undefined ? "" : String(max));
    const [activeField, setActiveField] = useState(null);

    useEffect(() => {
        if (activeField !== "value") {
            setValueInput(value === undefined ? "" : String(value));
        }
    }, [value, activeField]);

    useEffect(() => {
        if (activeField !== "min") {
            setMinInput(min === undefined ? "" : String(min));
        }
    }, [min, activeField]);

    useEffect(() => {
        if (activeField !== "max") {
            setMaxInput(max === undefined ? "" : String(max));
        }
    }, [max, activeField]);

    const formatValue = (val) => {
        if (Number.isNaN(val)) {
            return "";
        }
        if (typeof decimals === "number") {
            return Number(val).toFixed(decimals);
        }
        return String(val);
    };

    const handleNumberChange = (e) => {
        setValueInput(e.target.value);
    };

    const handleNumberBlur = () => {
        setActiveField(null);
        const parsed = Number(valueInput);
        if (Number.isNaN(parsed)) {
            setValueInput(formatValue(value));
            return;
        }
        const clamped = Math.min(max, Math.max(min, parsed));
        onChange(clamped);
        setValueInput(formatValue(clamped));
    };

    const handleMinChange = (e) => {
        if (!onMinChange) {
            return;
        }
        setMinInput(e.target.value);
    };

    const handleMinBlur = () => {
        if (!onMinChange) {
            return;
        }
        setActiveField(null);
        const parsed = Number(minInput);
        if (Number.isNaN(parsed)) {
            setMinInput(String(min));
            return;
        }
        const nextMin = Math.min(parsed, max);
        onMinChange(nextMin);
        if (value < nextMin) {
            onChange(nextMin);
        }
        setMinInput(String(nextMin));
    };

    const handleMaxChange = (e) => {
        if (!onMaxChange) {
            return;
        }
        setMaxInput(e.target.value);
    };

    const handleMaxBlur = () => {
        if (!onMaxChange) {
            return;
        }
        setActiveField(null);
        const parsed = Number(maxInput);
        if (Number.isNaN(parsed)) {
            setMaxInput(String(max));
            return;
        }
        const nextMax = Math.max(parsed, min);
        onMaxChange(nextMax);
        if (value > nextMax) {
            onChange(nextMax);
        }
        setMaxInput(String(nextMax));
    };

    return (
        <div className="form-group mb-3">
            <div className="d-flex align-items-center justify-content-between">
                <label className="form-label mb-1" htmlFor={inputId}>{label}</label>
                <div className="d-flex align-items-center gap-2">
                    {onMidiLearn && (
                        <button
                            className={`btn btn-sm ${isMidiLearning ? 'btn-warning' : 'btn-outline-secondary'}`}
                            onClick={onMidiLearn}
                            title="Click to learn MIDI control"
                        >
                            {isMidiLearning ? 'ðŸŽµ Learning...' : 'ðŸŽ¹'}
                        </button>
                    )}
                    {onMidiClear && midiMapping && (
                        <button
                            className="btn btn-sm btn-outline-danger"
                            onClick={onMidiClear}
                            title="Clear MIDI binding"
                        >
                            âœ–
                        </button>
                    )}
                    {midiMapping && (
                        <span className="badge badge-info" title={`CC${midiMapping.cc} CH${midiMapping.channel + 1}`}>
                            CC{midiMapping.cc}
                        </span>
                    )}
                </div>
            {showRangeInputs && (
                <>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Min</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={Number.MIN_SAFE_INTEGER}
                            max={max}
                            step={numberStep || step}
                            value={minInput}
                            onChange={handleMinChange}
                            onFocus={() => setActiveField("min")}
                            onBlur={handleMinBlur}
                        />
                    </div>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Max</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={min}
                            max={Number.MAX_SAFE_INTEGER}
                            step={numberStep || step}
                            value={maxInput}
                            onChange={handleMaxChange}
                            onFocus={() => setActiveField("max")}
                            onBlur={handleMaxBlur}
                        />
                    </div>
                    </>
            )}
                <div className="d-flex align-items-center">
                    <input
                        type="number"
                        className="form-control form-control-sm text-right mr-2"
                        style={{ width: "110px" }}
                        min={min}
                        max={max}
                        step={numberStep || step}
                        value={valueInput}
                        onChange={handleNumberChange}
                        onFocus={() => setActiveField("value")}
                        onBlur={handleNumberBlur}
                    />
                    <span className="text-muted small">{formatValue(value)}{unit || ""}</span>
                </div>
            </div>
            <input
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                className="form-control-range"
                id={inputId}
            />
        </div>
    );
}

function VoicePanel({
    voice,
    instrument,
    midiInputs,
    midiAccess,
    onMidiSelection,
    registerCcTarget,
    registerNoteRangeTarget,
    learningControlId,
    startMidiLearn,
    clearMidiBinding,
    ccMappings,
    onRename,
    onRemove,
    noteLearnTarget,
    startNoteLearn,
    stopNoteLearn
}) {
    const attackControl = useRangedControl(`${voice.id}:attack`, 0.01, `${voice.id}:attackMin`, 0.001, `${voice.id}:attackMax`, 1);
    const decayControl = useRangedControl(`${voice.id}:decay`, 0.2, `${voice.id}:decayMin`, 0.001, `${voice.id}:decayMax`, 2);
    const sustainControl = useRangedControl(`${voice.id}:sustain`, 0.7, `${voice.id}:sustainMin`, 0, `${voice.id}:sustainMax`, 1);
    const releaseControl = useRangedControl(`${voice.id}:release`, 0.5, `${voice.id}:releaseMin`, 0.001, `${voice.id}:releaseMax`, 2);
    const volumeControl = useRangedControl(`${voice.id}:volume`, 0.7, `${voice.id}:volumeMin`, 0, `${voice.id}:volumeMax`, 1);
    const harmonicsGammaControl = useRangedControl(`${voice.id}:harmonicsGamma`, 0.5, `${voice.id}:harmonicsGammaMin`, 0.1, `${voice.id}:harmonicsGammaMax`, 1);
    const evenHarmonicsScaleControl = useRangedControl(`${voice.id}:evenHarmonicsScale`, 0.5, `${voice.id}:evenHarmonicsScaleMin`, 0, `${voice.id}:evenHarmonicsScaleMax`, 1);
    const pitchBendControl = useRangedControl(`${voice.id}:pitchBend`, 0, `${voice.id}:pitchBendMin`, -2, `${voice.id}:pitchBendMax`, 2);
    const noteMinControl = useRangedControl(`${voice.id}:noteMin`, 0, `${voice.id}:noteMinMin`, 0, `${voice.id}:noteMinMax`, 127);
    const noteMaxControl = useRangedControl(`${voice.id}:noteMax`, 127, `${voice.id}:noteMaxMin`, 0, `${voice.id}:noteMaxMax`, 127);
    const noteMinEnabled = useLocalStorageNumberWithRef(`${voice.id}:noteMinEnabled`, 1);
    const noteMaxEnabled = useLocalStorageNumberWithRef(`${voice.id}:noteMaxEnabled`, 1);
    const adsrCanvasRef = useRef(null);
    const harmonicsCanvasRef = useRef(null);
    const waveformCanvasRef = useRef(null);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setAttack(attackControl.current);
    }, [attackControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setDecay(decayControl.current);
    }, [decayControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setSustain(sustainControl.current);
    }, [sustainControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setRelease(releaseControl.current);
    }, [releaseControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setVolume(volumeControl.current);
    }, [volumeControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setHarmonicsGamma(harmonicsGammaControl.current);
    }, [harmonicsGammaControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setEvenHarmonicsScale(evenHarmonicsScaleControl.current);
    }, [evenHarmonicsScaleControl.current, instrument]);

    useEffect(() => {
        if (!instrument) {
            return;
        }
        instrument.setPitchBend(pitchBendControl.current);
    }, [pitchBendControl.current, instrument]);

    useEffect(() => {
        const canvas = adsrCanvasRef.current;
        if (!canvas) {
            return;
        }
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        const sustainT = 0.3;
        const total = attackControl.current + decayControl.current + releaseControl.current + sustainT;
        const attackW = (attackControl.current / total) * width;
        const decayW = (decayControl.current / total) * width;
        const releaseW = (releaseControl.current / total) * width;
        const sustainW = (sustainT / total) * width;

        const attackY = height * 0.1;
        const sustainY = height - sustainControl.current * (height * 0.8) - height * 0.1;
        const baseY = height - height * 0.1;

        ctx.strokeStyle = "#28a745";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, baseY);
        ctx.lineTo(attackW, attackY);
        ctx.lineTo(attackW + decayW, sustainY);
        ctx.lineTo(attackW + decayW + sustainW, sustainY);
        ctx.lineTo(width, baseY);
        ctx.stroke();

        ctx.fillStyle = "rgba(40, 167, 69, 0.15)";
        ctx.beginPath();
        ctx.moveTo(0, baseY);
        ctx.lineTo(attackW, attackY);
        ctx.lineTo(attackW + decayW, sustainY);
        ctx.lineTo(attackW + decayW + sustainW, sustainY);
        ctx.lineTo(width, baseY);
        ctx.closePath();
        ctx.fill();
    }, [attackControl.current, decayControl.current, sustainControl.current, releaseControl.current]);

    useEffect(() => {
        const canvas = harmonicsCanvasRef.current;
        if (!canvas) {
            return;
        }
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        const barWidth = width / harmonicsCount;
        const maxValue = Math.max(1, evenHarmonicsScaleControl.current, harmonicsGammaControl.current);

        for (let i = 0; i < harmonicsCount; i++) {
            const base = Math.pow(harmonicsGammaControl.current, i);
            const value = (i % 2 === 1) ? base * evenHarmonicsScaleControl.current : base;
            const barHeight = (value / maxValue) * (height * 0.9);
            const x = i * barWidth;
            const y = height - barHeight;
            ctx.fillStyle = i % 2 === 1 ? "#17a2b8" : "#6c757d";
            ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
        }

        ctx.strokeStyle = "#dee2e6";
        ctx.lineWidth = 1;
        ctx.strokeRect(0, 0, width, height);
    }, [harmonicsGammaControl.current, evenHarmonicsScaleControl.current]);

    useEffect(() => {
        const canvas = waveformCanvasRef.current;
        if (!canvas) {
            return;
        }
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        const samples = 512;
        const waveData = new Float32Array(samples);

        for (let i = 0; i < samples; i++) {
            const t = (i / samples) * 2 * Math.PI;
            let sum = 0;
            for (let h = 1; h < harmonicsCount; h++) {
                const base = Math.pow(harmonicsGammaControl.current, h);
                const amplitude = (h % 2 === 0) ? base * evenHarmonicsScaleControl.current : base;
                sum += amplitude * Math.sin(h * t);
            }
            waveData[i] = sum;
        }

        const maxAbs = Math.max(...waveData.map(Math.abs));
        if (maxAbs > 0) {
            for (let i = 0; i < samples; i++) {
                waveData[i] /= maxAbs;
            }
        }

        ctx.strokeStyle = "#007bff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < samples; i++) {
            const x = (i / samples) * width;
            const y = height / 2 - waveData[i] * (height * 0.4);
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();

        ctx.strokeStyle = "#dee2e6";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, height / 2);
        ctx.lineTo(width, height / 2);
        ctx.stroke();

        ctx.strokeRect(0, 0, width, height);
    }, [harmonicsGammaControl.current, evenHarmonicsScaleControl.current]);

    useEffect(() => {
        const controlIds = [
            ["attack", attackControl],
            ["decay", decayControl],
            ["sustain", sustainControl],
            ["release", releaseControl],
            ["volume", volumeControl],
            ["harmonicsGamma", harmonicsGammaControl],
            ["evenHarmonicsScale", evenHarmonicsScaleControl],
            ["pitchBend", pitchBendControl]
        ];

        const cleanups = controlIds.map(([key, control]) => {
            return registerCcTarget(makeVoiceControlId(voice.id, key), {
                setState: control.set,
                minRef: control.min,
                maxRef: control.max
            });
        });

        const rangeCleanup = registerNoteRangeTarget(voice.id, {
            minValueRef: noteMinControl,
            maxValueRef: noteMaxControl,
            minEnabledRef: noteMinEnabled,
            maxEnabledRef: noteMaxEnabled,
            setMin: noteMinControl.set,
            setMax: noteMaxControl.set,
            setMinEnabled: noteMinEnabled.set,
            setMaxEnabled: noteMaxEnabled.set
        });

        return () => {
            cleanups.forEach((cleanup) => cleanup && cleanup());
            if (rangeCleanup) {
                rangeCleanup();
            }
        };
    }, [
        voice.id,
        registerCcTarget,
        registerNoteRangeTarget,
        attackControl.set,
        attackControl.min,
        attackControl.max,
        decayControl.set,
        decayControl.min,
        decayControl.max,
        sustainControl.set,
        sustainControl.min,
        sustainControl.max,
        releaseControl.set,
        releaseControl.min,
        releaseControl.max,
        volumeControl.set,
        volumeControl.min,
        volumeControl.max,
        harmonicsGammaControl.set,
        harmonicsGammaControl.min,
        harmonicsGammaControl.max,
        evenHarmonicsScaleControl.set,
        evenHarmonicsScaleControl.min,
        evenHarmonicsScaleControl.max,
        pitchBendControl.set,
        pitchBendControl.min,
        pitchBendControl.max,
        noteMinControl.set,
        noteMaxControl.set,
        noteMinEnabled.set,
        noteMaxEnabled.set
    ]);

    const isLearningMin = noteLearnTarget && noteLearnTarget.voiceId === voice.id && noteLearnTarget.kind === "min";
    const isLearningMax = noteLearnTarget && noteLearnTarget.voiceId === voice.id && noteLearnTarget.kind === "max";

    return (
        <div className="card mb-3">
            <div className="card-body">
                <div className="d-flex align-items-center justify-content-between mb-3">
                    <div className="d-flex align-items-center">
                        <input
                            className="form-control form-control-sm mr-2"
                            style={{ maxWidth: "180px" }}
                            value={voice.name}
                            onChange={(e) => onRename(voice.id, e.target.value)}
                        />
                        <small className="text-muted">{voice.id}</small>
                    </div>
                    {onRemove && (
                        <button className="btn btn-sm btn-outline-danger" onClick={() => onRemove(voice.id)}>
                            Remove
                        </button>
                    )}
                </div>

                <div className="form-group mb-3">
                    <label className="form-label mb-1">MIDI Inputs</label>
                    <select
                        className="form-control"
                        multiple
                        value={voice.selectedInputIds}
                        onChange={(e) => onMidiSelection(voice.id, e)}
                        disabled={!midiAccess || midiInputs.length === 0}
                    >
                        {midiInputs.length === 0 && <option value="">No MIDI devices</option>}
                        {midiInputs.map((input) => (
                            <option key={input.id} value={input.id}>
                                {input.manufacturer} {input.name}
                            </option>
                        ))}
                    </select>
                </div>

                <div className="row">
                    <div className="col-md-6">
                        <h3 className="h6">Note Range</h3>
                        <div className="d-flex align-items-center">
                            <input
                                type="number"
                                className="form-control form-control-sm mr-2"
                                style={{ maxWidth: "120px" }}
                                min={0}
                                max={127}
                                step={1}
                                value={noteMinControl.current}
                                onChange={(e) => noteMinControl.set(Number(e.target.value))}
                                disabled={!noteMinEnabled.current}
                            />
                            <button
                                className={`btn btn-sm ${isLearningMin ? "btn-warning" : "btn-outline-secondary"}`}
                                onClick={() => {
                                    if (isLearningMin) {
                                        stopNoteLearn();
                                    } else {
                                        noteMinEnabled.set(1);
                                        startNoteLearn(voice.id, "min");
                                    }
                                }}
                                disabled={!noteMinEnabled.current && !isLearningMin}
                            >
                                {isLearningMin ? "Listening..." : "Learn Min"}
                            </button>
                            <button
                                className="btn btn-sm btn-outline-dark ml-2"
                                onClick={() => noteMinEnabled.set(noteMinEnabled.current ? 0 : 1)}
                            >
                                {noteMinEnabled.current ? "No Min" : "Limit Min"}
                            </button>
                        </div>
                    </div>
                    <div className="col-md-6">
                        <h3 className="h6">&nbsp;</h3>
                        <div className="d-flex align-items-center">
                            <input
                                type="number"
                                className="form-control form-control-sm mr-2"
                                style={{ maxWidth: "120px" }}
                                min={0}
                                max={127}
                                step={1}
                                value={noteMaxControl.current}
                                onChange={(e) => noteMaxControl.set(Number(e.target.value))}
                                disabled={!noteMaxEnabled.current}
                            />
                            <button
                                className={`btn btn-sm ${isLearningMax ? "btn-warning" : "btn-outline-secondary"}`}
                                onClick={() => {
                                    if (isLearningMax) {
                                        stopNoteLearn();
                                    } else {
                                        noteMaxEnabled.set(1);
                                        startNoteLearn(voice.id, "max");
                                    }
                                }}
                                disabled={!noteMaxEnabled.current && !isLearningMax}
                            >
                                {isLearningMax ? "Listening..." : "Learn Max"}
                            </button>
                            <button
                                className="btn btn-sm btn-outline-dark ml-2"
                                onClick={() => noteMaxEnabled.set(noteMaxEnabled.current ? 0 : 1)}
                            >
                                {noteMaxEnabled.current ? "No Max" : "Limit Max"}
                            </button>
                        </div>
                    </div>
                </div>

                <div className="row">
                    <div className="col-md-6">
                        <h3 className="h6">Envelope</h3>
                        <SliderControl
                            label="Attack"
                            value={attackControl.current}
                            onChange={attackControl.set}
                            min={attackControl.min.current}
                            max={attackControl.max.current}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId={`${voice.id}-attackControl`}
                            onMinChange={attackControl.min.set}
                            onMaxChange={attackControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "attack"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "attack")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "attack")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "attack"))}
                        />
                        <SliderControl
                            label="Decay"
                            value={decayControl.current}
                            onChange={decayControl.set}
                            min={decayControl.min.current}
                            max={decayControl.max.current}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId={`${voice.id}-decayControl`}
                            onMinChange={decayControl.min.set}
                            onMaxChange={decayControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "decay"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "decay")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "decay")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "decay"))}
                        />
                        <SliderControl
                            label="Sustain"
                            value={sustainControl.current}
                            onChange={sustainControl.set}
                            min={sustainControl.min.current}
                            max={sustainControl.max.current}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId={`${voice.id}-sustainControl`}
                            onMinChange={sustainControl.min.set}
                            onMaxChange={sustainControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "sustain"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "sustain")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "sustain")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "sustain"))}
                        />
                        <SliderControl
                            label="Release"
                            value={releaseControl.current}
                            onChange={releaseControl.set}
                            min={releaseControl.min.current}
                            max={releaseControl.max.current}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId={`${voice.id}-releaseControl`}
                            onMinChange={releaseControl.min.set}
                            onMaxChange={releaseControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "release"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "release")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "release")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "release"))}
                        />
                        <div className="mb-3">
                            <canvas
                                ref={adsrCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                    </div>
                    <div className="col-md-6">
                        <h3 className="h6">Tone</h3>
                        <SliderControl
                            label="Volume"
                            value={volumeControl.current}
                            onChange={volumeControl.set}
                            min={volumeControl.min.current}
                            max={volumeControl.max.current}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId={`${voice.id}-volumeControl`}
                            onMinChange={volumeControl.min.set}
                            onMaxChange={volumeControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "volume"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "volume")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "volume")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "volume"))}
                        />
                        <SliderControl
                            label="Harmonics Gamma"
                            value={harmonicsGammaControl.current}
                            onChange={harmonicsGammaControl.set}
                            min={harmonicsGammaControl.min.current}
                            max={harmonicsGammaControl.max.current}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId={`${voice.id}-harmonicsGammaControl`}
                            onMinChange={harmonicsGammaControl.min.set}
                            onMaxChange={harmonicsGammaControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "harmonicsGamma"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "harmonicsGamma")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "harmonicsGamma")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "harmonicsGamma"))}
                        />
                        <SliderControl
                            label="Even Harmonics Scale"
                            value={evenHarmonicsScaleControl.current}
                            onChange={evenHarmonicsScaleControl.set}
                            min={evenHarmonicsScaleControl.min.current}
                            max={evenHarmonicsScaleControl.max.current}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId={`${voice.id}-evenHarmonicsScaleControl`}
                            onMinChange={evenHarmonicsScaleControl.min.set}
                            onMaxChange={evenHarmonicsScaleControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "evenHarmonicsScale"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "evenHarmonicsScale")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "evenHarmonicsScale")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "evenHarmonicsScale"))}
                        />
                        <SliderControl
                            label="Pitch Bend"
                            value={pitchBendControl.current}
                            onChange={pitchBendControl.set}
                            min={pitchBendControl.min.current}
                            max={pitchBendControl.max.current}
                            step={0.01}
                            numberStep={0.01}
                            unit=" semitones"
                            decimals={2}
                            inputId={`${voice.id}-pitchBendControl`}
                            onMinChange={pitchBendControl.min.set}
                            onMaxChange={pitchBendControl.max.set}
                            onMidiLearn={() => startMidiLearn(makeVoiceControlId(voice.id, "pitchBend"))}
                            isMidiLearning={learningControlId === makeVoiceControlId(voice.id, "pitchBend")}
                            midiMapping={ccMappings[makeVoiceControlId(voice.id, "pitchBend")]}
                            onMidiClear={() => clearMidiBinding(makeVoiceControlId(voice.id, "pitchBend"))}
                        />
                        <div className="mb-3">
                            <canvas
                                ref={harmonicsCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                        <div className="mb-3">
                            <canvas
                                ref={waveformCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
}

function App() {
    const [isAudioOn, setIsAudioOn] = useState(audioCtx.state === "running");
    const [enableButtonClicked, setEnableButtonClicked] = useState(false);
    const masterVolumeControl = useRangedControl("masterVolume", 0.8, "masterVolumeMin", 0, "masterVolumeMax", 1);
    const reverbMixControl = useRangedControl("reverbMix", 0.3, "reverbMixMin", 0, "reverbMixMax", 1);
    const reverbTimeControl = useRangedControl("reverbTime", 2, "reverbTimeMin", 0.1, "reverbTimeMax", 6);
    const reverbDecayControl = useRangedControl("reverbDecay", 2, "reverbDecayMin", 0.5, "reverbDecayMax", 6);
    const [midiAccess, setMidiAccess] = useState(null);
    const [midiInputs, setMidiInputs] = useState([]);
    const [midiStatus, setMidiStatus] = useState("MIDI not enabled");
    const [learningControlId, setLearningControlId] = useState(null);
    const [ccMappings, setCcMappings] = useState(() => JSON.parse(localStorage.getItem('ccMappings')) || {});
    const [learnStatus, setLearnStatus] = useState("");
    const [voices, setVoices, voicesRef] = useStateWithRef(loadStoredVoices);
    const [savedConfigs, setSavedConfigs] = useState(() => JSON.parse(localStorage.getItem("savedConfigs")) || []);
    const [configName, setConfigName] = useState("");
    const [configVersion, setConfigVersion] = useState(0);
    const [editingConfigId, setEditingConfigId] = useState(null);
    const [editingConfigName, setEditingConfigName] = useState("");
    const [isRecording, setIsRecording, isRecordingRef] = useStateWithRef(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [recordedChunks, setRecordedChunks] = useState([]);
    const mediaRecorderRef = useRef(null);
    const recordedChunksRef = useRef([]);
    const recordingTimerRef = useRef(null);
    const recordedMidiEventsRef = useRef([]);
    const recordStartTimeRef = useRef(null);
    const activeInputsRef = useRef(new Map());
    const learningControlIdRef = useRef(null);
    const ccMappingsRef = useRef({});
    const autoStopTimeoutRef = useRef(null);
    const spectrogramCanvasRef = useRef(null);
    const spectrogramAnimationRef = useRef(null);
    const voiceInstancesRef = useRef(new Map());
    const ccTargetsRef = useRef({});
    const [instrumentVersion, setInstrumentVersion] = useState(0);
    const noteRangeTargetsRef = useRef({});
    const [noteLearnTarget, setNoteLearnTarget] = useState(null);
    const noteLearnTargetRef = useRef(null);

    const registerCcTarget = useCallback((controlId, target) => {
        ccTargetsRef.current[controlId] = target;
        return () => {
            delete ccTargetsRef.current[controlId];
        };
    }, []);

    const registerNoteRangeTarget = useCallback((voiceId, target) => {
        noteRangeTargetsRef.current[voiceId] = target;
        return () => {
            delete noteRangeTargetsRef.current[voiceId];
        };
    }, []);

    const drawSpectrogram = () => {
      const canvas = spectrogramCanvasRef.current;
      if (!canvas) {
          return;
      }
      /** @type {CanvasRenderingContext2D} */
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      const nyquist = audioCtx.sampleRate / 2;
      const minFreq = 27.5; // A0
      const maxFreq = 4186.01; // C8
      const logMin = Math.log2(minFreq);
      const logMax = Math.log2(maxFreq);

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, width, height);

      const renderFrame = () => {
          analyser.getByteFrequencyData(dataArray);

          // squish existing image left by .5%
          ctx.drawImage(canvas, 0, 0, width , height, 0, 0, width * 0.995, height);

          const columnMax = new Float32Array(height);
          for (let i = 0; i < bufferLength; i++) {
              const freq = (i / bufferLength) * nyquist;
              if (freq < minFreq || freq > maxFreq) {
                  continue;
              }
              const logFreq = Math.log2(freq);
              const t = (logFreq - logMin) / (logMax - logMin);
              const y = Math.max(0, Math.min(height - 1, height - 1 - Math.round(t * (height - 1))));
              const value = dataArray[i] / 255;
              if (value > columnMax[y]) {
                  columnMax[y] = value;
              }
          }

          ctx.fillStyle = "#ffffff";
          ctx.fillRect(width - 1, 0, 1, height);
          for (let y = 0; y < height; y++) {
              const value = columnMax[y];
              if (value === 0) {
                  continue;
              }
              const hue = 220 - value * 220;
              const light = 85 - value * 55;
              ctx.fillStyle = `hsl(${hue}, 90%, ${light}%)`;
              ctx.fillRect(width - 1, y, 1, 1);
          }

          spectrogramAnimationRef.current = requestAnimationFrame(renderFrame);
      };

      renderFrame();
  };

    const updateMidiInputs = (access) => {
      const inputs = Array.from(access.inputs.values()).map((input) => ({
          id: input.id,
          name: input.name || "Unknown device",
          manufacturer: input.manufacturer || "Unknown manufacturer"
      }));
      setMidiInputs(inputs);
      if (inputs.length === 0) {
          setMidiStatus("No MIDI inputs found");
      } else {
          setMidiStatus(`${inputs.length} MIDI input${inputs.length === 1 ? "" : "s"} available`);
      }
  };

    const handleEnableMidi = async () => {
      if (!navigator.requestMIDIAccess) {
          setMidiStatus("Web MIDI not supported in this browser");
          return;
      }
      try {
          const access = await navigator.requestMIDIAccess();
          console.log(access);
          setMidiAccess(access);
          updateMidiInputs(access);
          connectSelectedInputs(access, getActiveInputIds(voicesRef.current));
          access.onstatechange = () => updateMidiInputs(access);
      } catch (err) {
          setMidiStatus("MIDI access denied");
      }
  };

    const handleMidiMessage = async (inputId, event) => {
      const [status, data1, data2] = event.data;
      const channel = status & 0x0f;
      const command = status & 0xf0;

      // Capture MIDI if recording
      if (isRecordingRef.current && recordStartTimeRef.current) {
          recordedMidiEventsRef.current.push({
              time: Date.now() - recordStartTimeRef.current,
              data: [...event.data]
          });
      }

      // log hex message
      console.log(`MIDI Message: ${[...event.data].map((b) => "0x" + b.toString(16).padStart(2, '0')).join(' ')} (${status}, ${channel}, ${command})`);

      // Handle CC learning mode
      if (learningControlIdRef.current) {
          const cc = data1;
          const newMapping = { ...ccMappingsRef.current };
          newMapping[learningControlIdRef.current] = { channel, cc };
          setCcMappings(newMapping);
          localStorage.setItem('ccMappings', JSON.stringify(newMapping));
          setLearnStatus(`Learned: CC${cc} on channel ${channel + 1}`);
          setLearningControlId(null);
          setTimeout(() => setLearnStatus(""), 2000);
          return;
      }

      // Handle note on/off for playing
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
          setIsAudioOn(true);
      }
    const targetVoices = inputId ? voicesRef.current.filter((voice) => voice.selectedInputIds.includes(inputId)) : voicesRef.current;

      if (command === 0x90 && data2 > 0) {
          if (noteLearnTargetRef.current) {
              const { voiceId, kind } = noteLearnTargetRef.current;
              const targetVoice = voicesRef.current.find((voice) => voice.id === voiceId);
              if (!inputId || (targetVoice && targetVoice.selectedInputIds.includes(inputId))) {
                  const rangeTarget = noteRangeTargetsRef.current[voiceId];
                  if (rangeTarget) {
                      const minValue = rangeTarget.minValueRef.current;
                      const maxValue = rangeTarget.maxValueRef.current;
                      if (kind === "min") {
                          rangeTarget.setMin(data1);
                          if (data1 > maxValue) {
                              rangeTarget.setMax(data1);
                          }
                          if (!rangeTarget.minEnabledRef.current) {
                              rangeTarget.setMinEnabled(1);
                          }
                      } else {
                          rangeTarget.setMax(data1);
                          if (data1 < minValue) {
                              rangeTarget.setMin(data1);
                          }
                          if (!rangeTarget.maxEnabledRef.current) {
                              rangeTarget.setMaxEnabled(1);
                          }
                      }
                  }
                  setNoteLearnTarget(null);
              }
          }
          if (autoStopTimeoutRef.current) {
              clearTimeout(autoStopTimeoutRef.current);
              autoStopTimeoutRef.current = null;
          }
          targetVoices.forEach((voice) => {
              const rangeTarget = noteRangeTargetsRef.current[voice.id];
              const minValue = rangeTarget ? rangeTarget.minValueRef.current : 0;
              const maxValue = rangeTarget ? rangeTarget.maxValueRef.current : 127;
              const minEnabled = rangeTarget ? Boolean(rangeTarget.minEnabledRef.current) : true;
              const maxEnabled = rangeTarget ? Boolean(rangeTarget.maxEnabledRef.current) : true;
              const minNote = minEnabled ? Math.min(minValue, maxValue) : 0;
              const maxNote = maxEnabled ? Math.max(minValue, maxValue) : 127;
              if (data1 < minNote || data1 > maxNote) {
                  return;
              }
              const instrument = voiceInstancesRef.current.get(voice.id);
              if (instrument) {
                  instrument.startNote(data1, data2 / 127);
              }
          });
      } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
          targetVoices.forEach((voice) => {
              const instrument = voiceInstancesRef.current.get(voice.id);
              if (instrument) {
                  instrument.stopNote(data1);
              }
          });
          if (isRecordingRef.current) {
              if (autoStopTimeoutRef.current) {
                  clearTimeout(autoStopTimeoutRef.current);
              }
              autoStopTimeoutRef.current = setTimeout(() => {
                  if (isRecordingRef.current) {
                      stopRecording();
                  }
              }, 60000);
          }
      }

      // Handle CC mapping for sliders
      const cc = data1;
      const value = mapCcValue(data2);
      for (const [controlId, mapping] of Object.entries(ccMappingsRef.current)) {
          if (mapping.channel === channel && mapping.cc === cc) {
              console.log(`Mapped CC${cc} on channel ${channel + 1} to ${controlId} with value ${value}`);
              handleCcValue(controlId, value);
          }
      }
  };

  const startRecording = () => {
      setRecordedChunks([]);
      recordedMidiEventsRef.current = [];
      recordStartTimeRef.current = Date.now();
      
      const mediaRecorder = new MediaRecorder(recordingDestination.stream, { mimeType: 'audio/webm;codecs=opus' });
      mediaRecorderRef.current = mediaRecorder;
      setRecordingTime(0);
      
      mediaRecorder.ondataavailable = (e) => {
        console.log('Data available:', e.data);
            setRecordedChunks([...recordedChunksRef.current, e.data]);
            const blob = new Blob([e.data], { type: 'audio/webm;codecs=opus' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `organ-recording-${recordStartTimeRef.current}.webm`;
            a.click();
            URL.revokeObjectURL(url);
      };
      
      mediaRecorder.start();
      mediaRecorder.onstop = () => {
          recordedChunksRef.current = recordedChunksRef.current;
      };
      setIsRecording(true);
      
      recordingTimerRef.current = setInterval(() => {
          setRecordingTime(t => t + 1);
      }, 1000);
  };

  const stopRecording = () => {
      if (mediaRecorderRef.current && isRecordingRef.current) {
          if (autoStopTimeoutRef.current) {
              clearTimeout(autoStopTimeoutRef.current);
              autoStopTimeoutRef.current = null;
          }
          mediaRecorderRef.current.stop();
          setIsRecording(false);
          if (recordingTimerRef.current) {
              clearInterval(recordingTimerRef.current);
          }
          // Download both files after stop. Delay slightly to ensure data is available.
          setTimeout(() => downloadMidiFile(), 100);
      }
  };

    const downloadMidiFile = () => {
        if (recordedMidiEventsRef.current.length === 0) {
            alert('No MIDI recording to download');
            return;
        }
        
        try {
            const Midi = window.Midi;
            if (!Midi) {
                alert('MIDI library not loaded');
                return;
            }
            
            const midi = new Midi();
            midi.header.setTempo(120);
            const track = midi.addTrack();
            
            // Track time in seconds (MIDI uses seconds, our events are in ms)
            let lastNoteStarts = {};
            
            recordedMidiEventsRef.current.forEach(({ time, data }) => {
                const [status, data1, data2] = data;
                const command = status & 0xf0;
                const midiTime = time / 1000; // Convert ms to seconds
                
                if (command === 0x90 && data2 > 0) {
                    // Note on
                    lastNoteStarts[data1] = midiTime;
                } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
                    // Note off
                    const startTime = lastNoteStarts[data1];
                    if (startTime !== undefined) {
                        const duration = midiTime - startTime;
                        track.addNote({
                            midi: data1,
                            time: startTime,
                            duration: Math.max(0.01, duration)
                        });
                        delete lastNoteStarts[data1];
                    }
                } else if (command === 0xb0) {
                    // CC - add as control change
                    track.addCC({
                        time: midiTime,
                        number: data1,
                        value: data2 / 127
                    });
                }
            });
            
            // Handle any notes still playing at end
            const endTime = Math.max(...recordedMidiEventsRef.current.map(e => e.time)) / 1000;
            Object.entries(lastNoteStarts).forEach(([midiNote, startTime]) => {
                track.addNote({
                    midi: Number(midiNote),
                    time: startTime,
                    duration: Math.max(0.01, endTime - startTime)
                });
            });
            
            // Download the MIDI file
            const blob = new Blob([midi.toArray()], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `organ-recording-${recordStartTimeRef.current}.mid`;
            a.click();
            URL.revokeObjectURL(url);
        } catch (err) {
            alert('Error creating MIDI file: ' + err.message);
            console.error(err);
        }
    };

        const handleCcValue = (controlId, normalizedValue) => {
            const target = ccTargetsRef.current[controlId];
            if (!target) {
                return;
            }
            const min = target.minRef.current;
            const max = target.maxRef.current;
            const scaledValue = min + normalizedValue * (max - min);
            target.setState(scaledValue);
        };



  const loadMidiRecording = (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const events = JSON.parse(e.target.result);
              if (Array.isArray(events)) {
                  playMidiRecording(events);
              } else {
                  alert('Invalid MIDI recording format');
              }
          } catch (err) {
              alert('Error loading MIDI recording: ' + err.message);
          }
      };
      reader.readAsText(file);
  };

  const playMidiRecording = (events) => {
      if (!audioCtx.state === 'running') {
          audioCtx.resume();
      }
      events.forEach(({ time, data }) => {
          setTimeout(() => {
              const fakeEvent = { data: new Uint8Array(data) };
              handleMidiMessage(null, fakeEvent);
          }, time);
      });
  };

  const startMidiLearn = (controlId) => {
      setLearningControlId(controlId);
      setLearnStatus(`Learning ${controlId}... Move a MIDI slider`);
  };

  const clearMidiBinding = (controlId) => {
      const newMapping = { ...ccMappingsRef.current };
      delete newMapping[controlId];
      setCcMappings(newMapping);
      localStorage.setItem('ccMappings', JSON.stringify(newMapping));
  };

    const connectSelectedInputs = (midiAccess, ids) => {
        console.log("Restoring MIDI connections to selected inputs:", ids);
      if (!midiAccess) {
          return;
      }
      const activeInputs = activeInputsRef.current;
      const nextIds = new Set(ids);

      for (const [id, input] of activeInputs.entries()) {
          if (!nextIds.has(id)) {
              input.onmidimessage = null;
              activeInputs.delete(id);
          }
      }

      ids.forEach((id) => {
          if (!activeInputs.has(id)) {
              const input = midiAccess.inputs.get(id);
              if (input) {
                  input.onmidimessage = (event) => handleMidiMessage(id, event);
                  activeInputs.set(id, input);
              }
          }
      });

      if (ids.length === 0) {
          setMidiStatus(midiInputs.length > 0 ? "No MIDI inputs selected" : "No MIDI inputs found");
      } else {
          setMidiStatus(`Connected to ${ids.length} input${ids.length === 1 ? "" : "s"}`);
      }
  };

  const getActiveInputIds = (voiceList) => {
      const ids = new Set();
      voiceList.forEach((voice) => {
          (voice.selectedInputIds || []).forEach((id) => ids.add(id));
      });
      return Array.from(ids.values());
  };

  const handleMidiSelection = (voiceId, e) => {
      const options = Array.from(e.target.selectedOptions);
      const ids = options.map((option) => option.value);
      setVoices((prev) => prev.map((voice) => (
          voice.id === voiceId ? { ...voice, selectedInputIds: ids } : voice
      )));
  };

  useEffect(() => {
      return () => {
          const activeInputs = activeInputsRef.current;
          for (const input of activeInputs.values()) {
              input.onmidimessage = null;
          }
          activeInputs.clear();
      };
  }, []);

    useEffect(() => {
        handleEnableMidi();
    }, []);

  useEffect(() => {
      masterBus.masterGain.gain.setValueAtTime(masterVolumeControl.current ** 2, audioCtx.currentTime);
  }, [masterVolumeControl.current]);

  useEffect(() => {
      const cleanups = [
          registerCcTarget(makeMasterControlId("volume"), {
              setState: masterVolumeControl.set,
              minRef: masterVolumeControl.min,
              maxRef: masterVolumeControl.max
          }),
          registerCcTarget(makeMasterControlId("reverbMix"), {
              setState: reverbMixControl.set,
              minRef: reverbMixControl.min,
              maxRef: reverbMixControl.max
          }),
          registerCcTarget(makeMasterControlId("reverbTime"), {
              setState: reverbTimeControl.set,
              minRef: reverbTimeControl.min,
              maxRef: reverbTimeControl.max
          }),
          registerCcTarget(makeMasterControlId("reverbDecay"), {
              setState: reverbDecayControl.set,
              minRef: reverbDecayControl.min,
              maxRef: reverbDecayControl.max
          })
      ];

      return () => {
          cleanups.forEach((cleanup) => cleanup && cleanup());
      };
  }, [
      registerCcTarget,
      masterVolumeControl.set,
      masterVolumeControl.min,
      masterVolumeControl.max,
      reverbMixControl.set,
      reverbMixControl.min,
      reverbMixControl.max,
      reverbTimeControl.set,
      reverbTimeControl.min,
      reverbTimeControl.max,
      reverbDecayControl.set,
      reverbDecayControl.min,
      reverbDecayControl.max
  ]);

  useEffect(() => {
      masterBus.wetGain.gain.setValueAtTime(reverbMixControl.current, audioCtx.currentTime);
      masterBus.dryGain.gain.setValueAtTime(1.0 - reverbMixControl.current, audioCtx.currentTime);
  }, [reverbMixControl.current]);

  useEffect(() => {
      masterBus.convolver.buffer = createReverbImpulse(reverbTimeControl.current, reverbDecayControl.current);
  }, [reverbTimeControl.current, reverbDecayControl.current]);

  useEffect(() => {
      drawSpectrogram();
      return () => {
          if (spectrogramAnimationRef.current) {
              cancelAnimationFrame(spectrogramAnimationRef.current);
              spectrogramAnimationRef.current = null;
          }
      };
  }, []);

  useEffect(() => {
      localStorage.setItem("voices", JSON.stringify(voices));
  }, [voices]);

  useEffect(() => {
      if (!midiAccess) {
          return;
      }
      connectSelectedInputs(midiAccess, getActiveInputIds(voices));
  }, [midiAccess, voices, midiInputs]);

  useEffect(() => {
      localStorage.setItem('ccMappings', JSON.stringify(ccMappings));
      ccMappingsRef.current = ccMappings;
  }, [ccMappings]);

  useEffect(() => {
      localStorage.setItem("savedConfigs", JSON.stringify(savedConfigs));
  }, [savedConfigs]);

  useEffect(() => {
      learningControlIdRef.current = learningControlId;
  }, [learningControlId]);

  useEffect(() => {
      noteLearnTargetRef.current = noteLearnTarget;
  }, [noteLearnTarget]);

  useEffect(() => {
      const map = voiceInstancesRef.current;
      const nextIds = new Set(voices.map((voice) => voice.id));
      let hasChanges = false;

      voices.forEach((voice) => {
          if (!map.has(voice.id)) {
              const instrument = new VoiceInstrument(masterBus);
              applyVoiceSettingsFromStorage(voice.id, instrument);
              map.set(voice.id, instrument);
              hasChanges = true;
          }
      });

      for (const [id, instrument] of map.entries()) {
          if (!nextIds.has(id)) {
              instrument.dispose();
              map.delete(id);
              hasChanges = true;
          }
      }

      if (hasChanges) {
          setInstrumentVersion((prev) => prev + 1);
      }
  }, [voices]);

  const handleTurnOn = async () => {
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
      }
      setIsAudioOn(audioCtx.state === "running");
      setEnableButtonClicked(true);
  };

  const addVoice = () => {
      setVoices((prev) => [...prev, ensureVoiceShape({}, prev.length)]);
  };

  const removeVoice = (voiceId) => {
      setVoices((prev) => prev.filter((voice) => voice.id !== voiceId));
  };

  const renameVoice = (voiceId, name) => {
      setVoices((prev) => prev.map((voice) => (
          voice.id === voiceId ? { ...voice, name } : voice
      )));
  };

  const snapshotVoiceValues = (voiceId) => {
      const values = {};
      Object.entries(voiceValueDefaults).forEach(([key, fallback]) => {
          values[key] = getStoredNumber(`${voiceId}:${key}`, fallback);
      });
      return values;
  };

  const snapshotMasterValues = () => {
      const values = {};
      Object.entries(masterValueDefaults).forEach(([key, fallback]) => {
          values[key] = getStoredNumber(key, fallback);
      });
      return values;
  };

  const createConfigSnapshot = () => {
      const currentVoices = voicesRef.current.map((voice, index) => ensureVoiceShape(voice, index));
      const voiceControls = {};
      currentVoices.forEach((voice) => {
          voiceControls[voice.id] = snapshotVoiceValues(voice.id);
      });

      return {
          id: createConfigId(),
          name: configName.trim() || "Untitled Config",
          createdAt: new Date().toISOString(),
          voices: currentVoices,
          master: snapshotMasterValues(),
          voiceControls,
          ccMappings: ccMappingsRef.current
      };
  };

  const applyMasterConfig = (master) => {
      if (!master) {
          return;
      }
      const nextMaster = { ...masterValueDefaults, ...master };
      masterVolumeControl.min.set(nextMaster.masterVolumeMin);
      masterVolumeControl.max.set(nextMaster.masterVolumeMax);
      masterVolumeControl.set(nextMaster.masterVolume);

      reverbMixControl.min.set(nextMaster.reverbMixMin);
      reverbMixControl.max.set(nextMaster.reverbMixMax);
      reverbMixControl.set(nextMaster.reverbMix);

      reverbTimeControl.min.set(nextMaster.reverbTimeMin);
      reverbTimeControl.max.set(nextMaster.reverbTimeMax);
      reverbTimeControl.set(nextMaster.reverbTime);

      reverbDecayControl.min.set(nextMaster.reverbDecayMin);
      reverbDecayControl.max.set(nextMaster.reverbDecayMax);
      reverbDecayControl.set(nextMaster.reverbDecay);

      masterBus.masterGain.gain.setValueAtTime(nextMaster.masterVolume ** 2, audioCtx.currentTime);
      masterBus.wetGain.gain.setValueAtTime(nextMaster.reverbMix, audioCtx.currentTime);
      masterBus.dryGain.gain.setValueAtTime(1.0 - nextMaster.reverbMix, audioCtx.currentTime);
      masterBus.convolver.buffer = createReverbImpulse(nextMaster.reverbTime, nextMaster.reverbDecay);
  };

  const applyConfig = (config) => {
      if (!config || !Array.isArray(config.voices)) {
          alert("Invalid config file");
          return;
      }
      voiceInstancesRef.current.forEach((instrument) => {
          instrument.stopAllNotesImmediate();
          instrument.dispose();
      });
      voiceInstancesRef.current.clear();
      const nextVoices = config.voices.map((voice, index) => ensureVoiceShape(voice, index));
      const voiceControls = config.voiceControls || {};

      nextVoices.forEach((voice) => {
          const values = voiceControls[voice.id] || {};
          Object.entries(voiceValueDefaults).forEach(([key, fallback]) => {
              const value = values.hasOwnProperty(key) ? values[key] : fallback;
              localStorage.setItem(`${voice.id}:${key}`, value);
          });
      });

      applyMasterConfig(config.master);
      setCcMappings(config.ccMappings || {});
      setVoices(nextVoices);
      setConfigName(config.name || "");
      setConfigVersion((prev) => prev + 1);
  };

  const handleSaveConfig = () => {
      const snapshot = createConfigSnapshot();
      setSavedConfigs((prev) => [snapshot, ...prev]);
      setConfigName("");
  };

  const handleRenameConfig = (configId, name) => {
      setSavedConfigs((prev) => prev.map((config) => (
          config.id === configId ? { ...config, name } : config
      )));
  };

  const startConfigEdit = (config) => {
      setEditingConfigId(config.id);
      setEditingConfigName(config.name || "");
  };

  const cancelConfigEdit = () => {
      setEditingConfigId(null);
      setEditingConfigName("");
  };

  const saveConfigEdit = (configId) => {
      handleRenameConfig(configId, editingConfigName.trim() || "Untitled Config");
      cancelConfigEdit();
  };

  const handleDeleteConfig = (configId) => {
      const target = savedConfigs.find((config) => config.id === configId);
      if (!target) {
          return;
      }
      if (window.confirm(`Delete config "${target.name}"?`)) {
          setSavedConfigs((prev) => prev.filter((config) => config.id !== configId));
      }
  };

  const handleExportConfig = (config) => {
      const createdAt = new Date(config.createdAt || Date.now());
      const dateStamp = `${createdAt.getFullYear()}-${String(createdAt.getMonth() + 1).padStart(2, "0")}-${String(createdAt.getDate()).padStart(2, "0")}_${String(createdAt.getHours()).padStart(2, "0")}-${String(createdAt.getMinutes()).padStart(2, "0")}-${String(createdAt.getSeconds()).padStart(2, "0")}`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${(config.name || "config").replace(/[^a-z0-9-_ ]/gi, "").trim() || "config"}-${dateStamp}.json`;
      a.click();
      URL.revokeObjectURL(url);
  };

  const handleExportAllConfigs = () => {
      savedConfigs.forEach((config, index) => {
          setTimeout(() => handleExportConfig(config), index * 120);
      });
  };

  const handleImportConfig = (file) => {
      if (!file) {
          return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const parsed = JSON.parse(e.target.result);
              if (!parsed || !Array.isArray(parsed.voices)) {
                  alert("Invalid config file");
                  return;
              }
              const imported = {
                  ...parsed,
                  id: createConfigId(),
                  name: parsed.name || file.name.replace(/\.json$/i, "") || "Imported Config",
                  createdAt: parsed.createdAt || new Date().toISOString()
              };
              setSavedConfigs((prev) => [imported, ...prev]);
          } catch (err) {
              alert("Error importing config: " + err.message);
          }
      };
      reader.readAsText(file);
  };

  const startNoteLearn = (voiceId, kind) => {
      setNoteLearnTarget({ voiceId, kind });
  };

  const stopNoteLearn = () => {
      setNoteLearnTarget(null);
  };

  return (
    <div className="container py-4">
        {!enableButtonClicked && (
            <div 
                style={{
                    position: "fixed",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 9999
                }}
            >
                <button 
                    className="btn btn-success btn-lg"
                    onClick={handleTurnOn}
                    style={{ fontSize: "32px", padding: "30px 60px", width: "50%", height: "50%" }}
                >
                    Click to Enable
                </button>
            </div>
        )}

        <div className="d-flex align-items-center justify-content-between mb-3">
            <h1 className="h3 mb-0">Audio Instrument</h1>
            <div className="d-flex gap-2">
                <button 
                    className={`btn btn-sm ${isRecording ? 'btn-danger' : 'btn-outline-danger'}`}
                    onClick={isRecording ? stopRecording : startRecording}
                >
                    {isRecording ? `â¹ Stop & Download (${recordingTime}s)` : 'âº Record'}
                </button>
                {/**
                <button 
                    className="btn btn-sm btn-outline-primary"
                    onClick={downloadMidiFile}
                    disabled={recordedMidiEventsRef.current.length === 0}
                >
                    ðŸ’¾ Download MIDI
                </button>
                <label className="btn btn-sm btn-outline-secondary mb-0">
                    ðŸ“ Load MIDI
                    <input type="file" accept=".json" onChange={(e) => e.target.files[0] && loadMidiRecording(e.target.files[0])} style={{display: 'none'}} />
                </label>**/}
            </div>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <div className="d-flex align-items-center justify-content-between mb-3">
                      <div className="d-flex align-items-center">
                        <input
                            className="form-control form-control-sm mr-2"
                            style={{ maxWidth: "220px" }}
                            placeholder="Config name"
                            value={configName}
                            onChange={(e) => setConfigName(e.target.value)}
                        />
                            <button
                                className="btn btn-sm btn-outline-primary"
                                style={{ minWidth: "190px" }}
                                onClick={handleSaveConfig}
                            >
                            Save Current Config
                        </button>
                    </div>
                        <div className="d-flex align-items-center gap-2">
                            <button
                                className="btn btn-sm btn-outline-secondary"
                                onClick={handleExportAllConfigs}
                                disabled={savedConfigs.length === 0}
                            >
                                Save All Configs
                            </button>
                            <label className="btn btn-sm btn-outline-secondary mb-0">
                                Import Config
                                <input
                                    type="file"
                                    accept="application/json,.json"
                                    onChange={(e) => handleImportConfig(e.target.files[0])}
                                    style={{ display: "none" }}
                                />
                            </label>
                        </div>
                </div>
                {savedConfigs.length === 0 ? (
                    <div className="text-muted small">No saved configs yet.</div>
                ) : (
                    <div className="list-group">
                        {savedConfigs.map((config) => (
                            <div key={config.id} className="list-group-item d-flex align-items-center justify-content-between">
                                <div>
                                        <div className="d-flex align-items-center">
                                            <input
                                                className="form-control form-control-sm mr-2"
                                                style={{ maxWidth: "260px" }}
                                                value={editingConfigId === config.id ? editingConfigName : config.name}
                                                onChange={(e) => setEditingConfigName(e.target.value)}
                                                readOnly={editingConfigId !== config.id}
                                            />
                                            {editingConfigId === config.id ? (
                                                <>
                                                    <button
                                                        className="btn btn-sm btn-outline-success mr-1"
                                                        onClick={() => saveConfigEdit(config.id)}
                                                        title="Save"
                                                    >
                                                        âœ…
                                                    </button>
                                                    <button
                                                        className="btn btn-sm btn-outline-secondary mr-2"
                                                        onClick={cancelConfigEdit}
                                                        title="Cancel"
                                                    >
                                                        âŒ
                                                    </button>
                                                </>
                                            ) : (
                                                <button
                                                    className="btn btn-sm btn-outline-secondary mr-2"
                                                    onClick={() => startConfigEdit(config)}
                                                    title="Edit name"
                                                >
                                                    âœï¸
                                                </button>
                                            )}
                                            <span className="text-muted small" style={{ whiteSpace: "nowrap" }}>
                                                {new Date(config.createdAt).toLocaleString(undefined, { hour12: false })}
                                            </span>
                                        </div>
                                </div>
                                <div className="d-flex gap-2">
                                    <button
                                        className="btn btn-sm btn-outline-success"
                                        onClick={() => applyConfig(config)}
                                    >
                                        Load
                                    </button>
                                    <button
                                        className="btn btn-sm btn-outline-secondary"
                                        onClick={() => handleExportConfig(config)}
                                    >
                                        Export
                                    </button>
                                    <button
                                        className="btn btn-sm btn-outline-danger"
                                        onClick={() => handleDeleteConfig(config.id)}
                                    >
                                        Delete
                                    </button>
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <div className="form-group mb-3">
                    <div className="d-flex align-items-center justify-content-between">
                        <label className="form-label mb-0">MIDI Inputs</label>
                        <button className="btn btn-outline-secondary btn-sm" onClick={handleEnableMidi}>
                            {midiAccess ? "Refresh MIDI" : "Enable MIDI"}
                        </button>
                    </div>
                    <small className="text-muted d-block mb-2">{midiStatus}</small>
                    {learnStatus && <small className="text-info d-block mb-2">{learnStatus}</small>}
                    <div className="text-muted small">
                        Assign MIDI inputs per voice below.
                    </div>
                    {midiInputs.length > 0 && (
                        <div className="mt-2">
                            {midiInputs.map((input) => (
                                <div key={input.id} className="small">
                                    {input.manufacturer} {input.name}
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <h2 className="h5">Master Output</h2>
                <SliderControl
                    label="Master Volume"
                    value={masterVolumeControl.current}
                    onChange={masterVolumeControl.set}
                    min={masterVolumeControl.min.current}
                    max={masterVolumeControl.max.current}
                    step={0.01}
                    numberStep={0.01}
                    unit=""
                    decimals={2}
                    inputId="masterVolumeControl"
                    onMinChange={masterVolumeControl.min.set}
                    onMaxChange={masterVolumeControl.max.set}
                    onMidiLearn={() => startMidiLearn(makeMasterControlId("volume"))}
                    isMidiLearning={learningControlId === makeMasterControlId("volume")}
                    midiMapping={ccMappings[makeMasterControlId("volume")]}
                    onMidiClear={() => clearMidiBinding(makeMasterControlId("volume"))}
                />
                <SliderControl
                    label="Reverb Mix"
                    value={reverbMixControl.current}
                    onChange={reverbMixControl.set}
                    min={reverbMixControl.min.current}
                    max={reverbMixControl.max.current}
                    step={0.01}
                    numberStep={0.01}
                    unit=""
                    decimals={2}
                    inputId="reverbMixControl"
                    onMinChange={reverbMixControl.min.set}
                    onMaxChange={reverbMixControl.max.set}
                    onMidiLearn={() => startMidiLearn(makeMasterControlId("reverbMix"))}
                    isMidiLearning={learningControlId === makeMasterControlId("reverbMix")}
                    midiMapping={ccMappings[makeMasterControlId("reverbMix")]}
                    onMidiClear={() => clearMidiBinding(makeMasterControlId("reverbMix"))}
                />
                <SliderControl
                    label="Reverb Time"
                    value={reverbTimeControl.current}
                    onChange={reverbTimeControl.set}
                    min={reverbTimeControl.min.current}
                    max={reverbTimeControl.max.current}
                    step={0.1}
                    numberStep={0.1}
                    unit="s"
                    decimals={2}
                    inputId="reverbTimeControl"
                    onMinChange={reverbTimeControl.min.set}
                    onMaxChange={reverbTimeControl.max.set}
                    onMidiLearn={() => startMidiLearn(makeMasterControlId("reverbTime"))}
                    isMidiLearning={learningControlId === makeMasterControlId("reverbTime")}
                    midiMapping={ccMappings[makeMasterControlId("reverbTime")]}
                    onMidiClear={() => clearMidiBinding(makeMasterControlId("reverbTime"))}
                />
                <SliderControl
                    label="Reverb Decay"
                    value={reverbDecayControl.current}
                    onChange={reverbDecayControl.set}
                    min={reverbDecayControl.min.current}
                    max={reverbDecayControl.max.current}
                    step={0.1}
                    numberStep={0.1}
                    unit=""
                    decimals={2}
                    inputId="reverbDecayControl"
                    onMinChange={reverbDecayControl.min.set}
                    onMaxChange={reverbDecayControl.max.set}
                    onMidiLearn={() => startMidiLearn(makeMasterControlId("reverbDecay"))}
                    isMidiLearning={learningControlId === makeMasterControlId("reverbDecay")}
                    midiMapping={ccMappings[makeMasterControlId("reverbDecay")]}
                    onMidiClear={() => clearMidiBinding(makeMasterControlId("reverbDecay"))}
                />
                <div className="mb-3">
                    <canvas
                        ref={spectrogramCanvasRef}
                        width="320"
                        height="140"
                        style={{ width: "100%", background: "#fff", borderRadius: "6px" }}
                    />
                </div>
            </div>
        </div>

        {voices.map((voice) => (
            <VoicePanel
            key={`${voice.id}-${configVersion}`}
                voice={voice}
                instrument={voiceInstancesRef.current.get(voice.id)}
                midiInputs={midiInputs}
                midiAccess={midiAccess}
                onMidiSelection={handleMidiSelection}
                registerCcTarget={registerCcTarget}
                registerNoteRangeTarget={registerNoteRangeTarget}
                learningControlId={learningControlId}
                startMidiLearn={startMidiLearn}
                clearMidiBinding={clearMidiBinding}
                ccMappings={ccMappings}
                onRename={renameVoice}
                onRemove={removeVoice}
                noteLearnTarget={noteLearnTarget}
                startNoteLearn={startNoteLearn}
                stopNoteLearn={stopNoteLearn}
            />
        ))}

        <div className="d-flex align-items-center justify-content-between mb-2">
            <h2 className="h5 mb-0">Voices</h2>
            <button className="btn btn-sm btn-outline-primary" onClick={addVoice}>
                Add Voice
            </button>
        </div>
    </div>
  )
}
ReactDOM.render(React.createElement(App), document.getElementById("app"))
</script>
</body>
</html>
