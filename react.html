<!DOCTYPE html>
<html lang="en-US">
<!-- Simple index.html with in-browser jsx compilation -->
<head>
<title>App</title>
<script src="https://unpkg.com/lodash@4.17.21" crossorigin></script>
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-bootstrap@1.5.2/dist/react-bootstrap.js" crossorigin></script>
<script src="https://unpkg.com/react-router-dom@5.2.0/umd/react-router-dom.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone@7.20.12/babel.js"></script>
<!-- Useful things
https://github.com/johndiiorio/react-useinterval/blob/master/src/index.tsx
https://github.com/dance2die/react-use-localstorage/blob/master/src/index.ts
-->
<!-- no 404 request for icon 
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">-->
<link href="https://getbootstrap.com/docs/4.6/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<style>
</style>
</head>
<body>
<div id="app"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;
const { HashRouter, Link, Route, useRouteMatch } = ReactRouterDOM;
const { Dropdown } = ReactBootstrap;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function createReverbImpulse(seconds, decay) {
    const rate = audioCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * rate));
    const impulse = audioCtx.createBuffer(2, length, rate);
    for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const channelData = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
        }
    }
    return impulse;
}

function createCompressor() {
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;  // Start compressing at -24dB
    compressor.knee.value = 30;        // Smooth compression curve
    compressor.ratio.value = 12;       // Strong compression (12:1)
    compressor.attack.value = 0.01;   // Fast attack (3ms)
    compressor.release.value = 0.25;   // Medium release (250ms)
    return compressor;
}

const compressor = createCompressor();
compressor.connect(audioCtx.destination);

function createInstrumentRootNode(config) {
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = config.volume || 1.0;

    const dryGain = audioCtx.createGain();
    dryGain.gain.value = config.dryMix || 0.9;
    dryGain.connect(masterGain);

    const wetGain = audioCtx.createGain();
    wetGain.gain.value = config.wetMix || 0.2;
    wetGain.connect(masterGain);

    const reverbNode = audioCtx.createGain();
    reverbNode.connect(wetGain);

    const convolver = audioCtx.createConvolver();
    convolver.buffer = createReverbImpulse(config.reverb.seconds || 3, config.reverb.decay || 2);
    reverbNode.connect(convolver);
    convolver.connect(wetGain);

    return { masterGain, dryGain, wetGain, reverbNode, convolver };
}

class NoteInstrument {
    constructor() {
        this.rootNode = createInstrumentRootNode({
            volume: 0.7,
            dryMix: 0.8,
            wetMix: 0.3,
            reverb: { seconds: 2, decay: 2 }
        });
        this.rootNode.masterGain.connect(compressor);
        this.noteOscs = {};
        this.envelope = {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.7,
            release: 0.5
        };
    }

    setAttack(value) {
        this.envelope.attack = value;
    }

    setDecay(value) {
        this.envelope.decay = value;
    }

    setSustain(value) {
        this.envelope.sustain = value;
    }

    setRelease(value) {
        this.envelope.release = value;
    }

    setVolume(value) {
        this.rootNode.masterGain.gain.setValueAtTime(value, audioCtx.currentTime);
    }

    setReverbMix(value) {
        this.rootNode.wetGain.gain.setValueAtTime(value, audioCtx.currentTime);
        this.rootNode.dryGain.gain.setValueAtTime(1.0 - value, audioCtx.currentTime);
    }

    setReverbTime(seconds, decay) {
        const convolver = this.rootNode.convolver;
        convolver.buffer = createReverbImpulse(seconds, decay);
    }

    startNote(note, velocity = 1.0) {
        const noteFrequency = 440 * Math.pow(2, (note - 69) / 12);
        const noteWavelength = 1 / noteFrequency;
        const attack = Math.max(this.envelope.attack, noteWavelength);
        if (this.noteOscs[note]) {
            const existing = this.noteOscs[note];
            existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, audioCtx.currentTime);
            existing.gainNode.gain.linearRampToValueAtTime(velocity, audioCtx.currentTime + attack);
            existing.gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, audioCtx.currentTime + attack + this.envelope.decay);
            return;
        }
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.type = 'sine';
        osc.setPeriodicWave(audioCtx.createPeriodicWave(
            new Float32Array([0, 0, 0, 0, 0]),
            new Float32Array([1, 0.5, 0.25, 0.125, 0.0625])
        ));
        osc.frequency.value = noteFrequency;

        const now = audioCtx.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(velocity, now + attack);
        gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, now + attack + this.envelope.decay);

        osc.connect(gainNode);
        gainNode.connect(this.rootNode.dryGain);
        gainNode.connect(this.rootNode.reverbNode);

        osc.start();
        this.noteOscs[note] = { osc, gainNode };
    }

    stopNote(note) {
        const existing = this.noteOscs[note];
        if (existing) {
            const now = audioCtx.currentTime;
            existing.gainNode.gain.cancelScheduledValues(now);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, now);
            existing.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
            setTimeout(() => {
                if (existing.gainNode.gain === 0) {
                    existing.osc.stop();
                    existing.osc.disconnect();
                    existing.gainNode.disconnect();
                }
            }, this.envelope.release * 1000 + 100);
        }
    }
}

const app = document.getElementById("app");

const instrument = new NoteInstrument();

const getStoredNumber = (key, fallbackValue) => {
    const raw = localStorage.getItem(key);
    if (raw === null || raw === undefined || raw === "") {
        return fallbackValue;
    }
    const parsed = Number(raw);
    return Number.isFinite(parsed) ? parsed : fallbackValue;
};

function SliderControl({
    label,
    value,
    onChange,
    min,
    max,
    step,
    unit,
    decimals = 2,
    numberStep,
    inputId,
    showRangeInputs = true,
    onMinChange,
    onMaxChange
}) {
    const formatValue = (val) => {
        if (Number.isNaN(val)) {
            return "";
        }
        if (typeof decimals === "number") {
            return Number(val).toFixed(decimals);
        }
        return String(val);
    };

    const handleNumberChange = (e) => {
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const clamped = Math.min(max, Math.max(min, parsed));
            onChange(clamped);
        }
    };

    const handleMinChange = (e) => {
        if (!onMinChange) {
            return;
        }
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const nextMin = Math.min(parsed, max);
            onMinChange(nextMin);
            if (value < nextMin) {
                onChange(nextMin);
            }
        }
    };

    const handleMaxChange = (e) => {
        if (!onMaxChange) {
            return;
        }
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const nextMax = Math.max(parsed, min);
            onMaxChange(nextMax);
            if (value > nextMax) {
                onChange(nextMax);
            }
        }
    };

    return (
        <div className="form-group mb-3">
            <div className="d-flex align-items-center justify-content-between">
                <label className="form-label mb-1" htmlFor={inputId}>{label}</label>
            {showRangeInputs && (
                <>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Min</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={Number.MIN_SAFE_INTEGER}
                            max={max}
                            step={numberStep || step}
                            value={min}
                            onChange={handleMinChange}
                        />
                    </div>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Max</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={min}
                            max={Number.MAX_SAFE_INTEGER}
                            step={numberStep || step}
                            value={max}
                            onChange={handleMaxChange}
                        />
                    </div>
                    </>
            )}
                <div className="d-flex align-items-center">
                    <input
                        type="number"
                        className="form-control form-control-sm text-right mr-2"
                        style={{ width: "110px" }}
                        min={min}
                        max={max}
                        step={numberStep || step}
                        value={value}
                        onChange={handleNumberChange}
                    />
                    <span className="text-muted small">{formatValue(value)}{unit || ""}</span>
                </div>
            </div>
            <input
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                className="form-control-range"
                id={inputId}
            />
        </div>
    );
}

function App() {
    const [isAudioOn, setIsAudioOn] = useState(audioCtx.state === "running");
    const [attack, setAttack] = useState(() => getStoredNumber("attack", 0.01));
    const [decay, setDecay] = useState(() => getStoredNumber("decay", 0.2));
    const [sustain, setSustain] = useState(() => getStoredNumber("sustain", 0.7));
    const [release, setRelease] = useState(() => getStoredNumber("release", 0.5));
    const [volume, setVolume] = useState(() => getStoredNumber("volume", 0.7));
    const [reverbMix, setReverbMix] = useState(() => getStoredNumber("reverbMix", 0.3));
    const [reverbTime, setReverbTime] = useState(() => getStoredNumber("reverbTime", 2));
    const [reverbDecay, setReverbDecay] = useState(() => getStoredNumber("reverbDecay", 2));
    const [attackMin, setAttackMin] = useState(() => getStoredNumber("attackMin", 0.001));
    const [attackMax, setAttackMax] = useState(() => getStoredNumber("attackMax", 1));
    const [decayMin, setDecayMin] = useState(() => getStoredNumber("decayMin", 0.001));
    const [decayMax, setDecayMax] = useState(() => getStoredNumber("decayMax", 2));
    const [sustainMin, setSustainMin] = useState(() => getStoredNumber("sustainMin", 0));
    const [sustainMax, setSustainMax] = useState(() => getStoredNumber("sustainMax", 1));
    const [releaseMin, setReleaseMin] = useState(() => getStoredNumber("releaseMin", 0.001));
    const [releaseMax, setReleaseMax] = useState(() => getStoredNumber("releaseMax", 2));
    const [volumeMin, setVolumeMin] = useState(() => getStoredNumber("volumeMin", 0));
    const [volumeMax, setVolumeMax] = useState(() => getStoredNumber("volumeMax", 1));
    const [reverbMixMin, setReverbMixMin] = useState(() => getStoredNumber("reverbMixMin", 0));
    const [reverbMixMax, setReverbMixMax] = useState(() => getStoredNumber("reverbMixMax", 1));
    const [reverbTimeMin, setReverbTimeMin] = useState(() => getStoredNumber("reverbTimeMin", 0.1));
    const [reverbTimeMax, setReverbTimeMax] = useState(() => getStoredNumber("reverbTimeMax", 6));
    const [reverbDecayMin, setReverbDecayMin] = useState(() => getStoredNumber("reverbDecayMin", 0.5));
    const [reverbDecayMax, setReverbDecayMax] = useState(() => getStoredNumber("reverbDecayMax", 6));
    const [midiAccess, setMidiAccess] = useState(null);
    const [midiInputs, setMidiInputs] = useState([]);
    const [selectedInputIds, setSelectedInputIds] = useState(() => JSON.parse(localStorage.getItem('selectedInputIds')) || []);
    const [midiStatus, setMidiStatus] = useState("MIDI not enabled");
    const activeInputsRef = useRef(new Map());

  const updateMidiInputs = (access) => {
      const inputs = Array.from(access.inputs.values()).map((input) => ({
          id: input.id,
          name: input.name || "Unknown device",
          manufacturer: input.manufacturer || "Unknown manufacturer"
      }));
      setMidiInputs(inputs);
      if (inputs.length === 0) {
          setMidiStatus("No MIDI inputs found");
      } else {
          setMidiStatus(`${inputs.length} MIDI input${inputs.length === 1 ? "" : "s"} available`);
      }
  };

  const handleEnableMidi = async () => {
      if (!navigator.requestMIDIAccess) {
          setMidiStatus("Web MIDI not supported in this browser");
          return;
      }
      try {
          const access = await navigator.requestMIDIAccess();
          console.log(access);
          setMidiAccess(access);
          updateMidiInputs(access);
          connectSelectedInputs(access, selectedInputIds);
          access.onstatechange = () => updateMidiInputs(access);
      } catch (err) {
          setMidiStatus("MIDI access denied");
      }
  };

  const handleMidiMessage = async (event) => {
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
          setIsAudioOn(true);
      }
      const [status, note, velocity] = event.data;
      const command = status & 0xf0;
      if (command === 0x90 && velocity > 0) {
          instrument.startNote(note, velocity / 127);
      } else if (command === 0x80 || (command === 0x90 && velocity === 0)) {
          instrument.stopNote(note);
      }
  };

  const connectSelectedInputs = (midiAccess, ids) => {
    console.log("Restoring MIDI connections to selected inputs:", selectedInputIds);
      if (!midiAccess) {
          return;
      }
      const activeInputs = activeInputsRef.current;
      const nextIds = new Set(ids);

      for (const [id, input] of activeInputs.entries()) {
          if (!nextIds.has(id)) {
              input.onmidimessage = null;
              activeInputs.delete(id);
          }
      }

      ids.forEach((id) => {
          if (!activeInputs.has(id)) {
              const input = midiAccess.inputs.get(id);
              if (input) {
                  input.onmidimessage = handleMidiMessage;
                  activeInputs.set(id, input);
              }
          }
      });

      if (ids.length === 0) {
          setMidiStatus(midiInputs.length > 0 ? "No MIDI inputs selected" : "No MIDI inputs found");
      } else {
          setMidiStatus(`Connected to ${ids.length} input${ids.length === 1 ? "" : "s"}`);
      }
  };

  const handleMidiSelection = (e) => {
      const options = Array.from(e.target.selectedOptions);
      const ids = options.map((option) => option.value);
      setSelectedInputIds(ids);
      connectSelectedInputs(midiAccess, ids);
  };

  useEffect(() => {
      return () => {
          const activeInputs = activeInputsRef.current;
          for (const input of activeInputs.values()) {
              input.onmidimessage = null;
          }
          activeInputs.clear();
      };
  }, []);

    useEffect(() => {
        handleEnableMidi();
    }, []);

  useEffect(() => {
      localStorage.setItem('attack', attack);
      instrument.setAttack(attack);
  }, [attack]);

  useEffect(() => {
      localStorage.setItem('decay', decay);
      instrument.setDecay(decay);
  }, [decay]);

  useEffect(() => {
      localStorage.setItem('sustain', sustain);
      instrument.setSustain(sustain);
  }, [sustain]);

  useEffect(() => {
      localStorage.setItem('release', release);
      instrument.setRelease(release);
  }, [release]);

  useEffect(() => {
      localStorage.setItem('volume', volume);
      instrument.setVolume(volume);
  }, [volume]);

  useEffect(() => {
      localStorage.setItem('reverbMix', reverbMix);
      instrument.setReverbMix(reverbMix);
  }, [reverbMix]);

  useEffect(() => {
      localStorage.setItem('reverbTime', reverbTime);
      localStorage.setItem('reverbDecay', reverbDecay);
      instrument.setReverbTime(reverbTime, reverbDecay);
  }, [reverbTime, reverbDecay]);

  useEffect(() => {
      localStorage.setItem("attackMin", attackMin);
  }, [attackMin]);

  useEffect(() => {
      localStorage.setItem("attackMax", attackMax);
  }, [attackMax]);

  useEffect(() => {
      localStorage.setItem("decayMin", decayMin);
  }, [decayMin]);

  useEffect(() => {
      localStorage.setItem("decayMax", decayMax);
  }, [decayMax]);

  useEffect(() => {
      localStorage.setItem("sustainMin", sustainMin);
  }, [sustainMin]);

  useEffect(() => {
      localStorage.setItem("sustainMax", sustainMax);
  }, [sustainMax]);

  useEffect(() => {
      localStorage.setItem("releaseMin", releaseMin);
  }, [releaseMin]);

  useEffect(() => {
      localStorage.setItem("releaseMax", releaseMax);
  }, [releaseMax]);

  useEffect(() => {
      localStorage.setItem("volumeMin", volumeMin);
  }, [volumeMin]);

  useEffect(() => {
      localStorage.setItem("volumeMax", volumeMax);
  }, [volumeMax]);

  useEffect(() => {
      localStorage.setItem("reverbMixMin", reverbMixMin);
  }, [reverbMixMin]);

  useEffect(() => {
      localStorage.setItem("reverbMixMax", reverbMixMax);
  }, [reverbMixMax]);

  useEffect(() => {
      localStorage.setItem("reverbTimeMin", reverbTimeMin);
  }, [reverbTimeMin]);

  useEffect(() => {
      localStorage.setItem("reverbTimeMax", reverbTimeMax);
  }, [reverbTimeMax]);

  useEffect(() => {
      localStorage.setItem("reverbDecayMin", reverbDecayMin);
  }, [reverbDecayMin]);

  useEffect(() => {
      localStorage.setItem("reverbDecayMax", reverbDecayMax);
  }, [reverbDecayMax]);

  useEffect(() => {
      localStorage.setItem('selectedInputIds', JSON.stringify(selectedInputIds));
  }, [selectedInputIds]);

  const handleAttack = (e) => setAttack(Number(e.target.value));
  const handleDecay = (e) => setDecay(Number(e.target.value));
  const handleSustain = (e) => setSustain(Number(e.target.value));
  const handleRelease = (e) => setRelease(Number(e.target.value));
  const handleVolume = (e) => setVolume(Number(e.target.value));
  const handleReverbMix = (e) => setReverbMix(Number(e.target.value));
  const handleReverbTime = (e) => setReverbTime(Number(e.target.value));
  const handleReverbDecay = (e) => setReverbDecay(Number(e.target.value));

  const handleTurnOn = async () => {
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
      }
      setIsAudioOn(audioCtx.state === "running");
  };

  return (
    <div className="container py-4">
        <div className="mb-4">
            <button 
                className="btn btn-success btn-lg btn-block"
                onClick={handleTurnOn}
                style={{ fontSize: "24px", padding: "20px" }}
            >
                {isAudioOn ? "âœ“ Enabled" : "Click to Enable"}
            </button>
        </div>

        <div className="d-flex align-items-center justify-content-between mb-3">
            <h1 className="h3 mb-0">React Audio Instrument</h1>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <div className="form-group mb-3">
                    <div className="d-flex align-items-center justify-content-between">
                        <label className="form-label mb-0">MIDI Inputs</label>
                        <button className="btn btn-outline-secondary btn-sm" onClick={handleEnableMidi}>
                            {midiAccess ? "Refresh MIDI" : "Enable MIDI"}
                        </button>
                    </div>
                    <small className="text-muted d-block mb-2">{midiStatus}</small>
                    <select
                        className="form-control"
                        multiple
                        value={selectedInputIds}
                        onChange={handleMidiSelection}
                        disabled={!midiAccess || midiInputs.length === 0}
                    >
                        {midiInputs.length === 0 && <option value="">No MIDI devices</option>}
                        {midiInputs.map((input) => (
                            <option key={input.id} value={input.id}>
                                {input.manufacturer} {input.name}
                            </option>
                        ))}
                    </select>
                </div>

                <div className="row">
                    <div className="col-md-6">
                        <h2 className="h5">Envelope</h2>
                        <SliderControl
                            label="Attack"
                            value={attack}
                            onChange={setAttack}
                            min={attackMin}
                            max={attackMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="attackControl"
                            onMinChange={setAttackMin}
                            onMaxChange={setAttackMax}
                        />
                        <SliderControl
                            label="Decay"
                            value={decay}
                            onChange={setDecay}
                            min={decayMin}
                            max={decayMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="decayControl"
                            onMinChange={setDecayMin}
                            onMaxChange={setDecayMax}
                        />
                        <SliderControl
                            label="Sustain"
                            value={sustain}
                            onChange={setSustain}
                            min={sustainMin}
                            max={sustainMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="sustainControl"
                            onMinChange={setSustainMin}
                            onMaxChange={setSustainMax}
                        />
                        <SliderControl
                            label="Release"
                            value={release}
                            onChange={setRelease}
                            min={releaseMin}
                            max={releaseMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="releaseControl"
                            onMinChange={setReleaseMin}
                            onMaxChange={setReleaseMax}
                        />
                    </div>
                    <div className="col-md-6">
                        <h2 className="h5">Output</h2>
                        <SliderControl
                            label="Volume"
                            value={volume}
                            onChange={setVolume}
                            min={volumeMin}
                            max={volumeMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="volumeControl"
                            onMinChange={setVolumeMin}
                            onMaxChange={setVolumeMax}
                        />
                        <SliderControl
                            label="Reverb Mix"
                            value={reverbMix}
                            onChange={setReverbMix}
                            min={reverbMixMin}
                            max={reverbMixMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="reverbMixControl"
                            onMinChange={setReverbMixMin}
                            onMaxChange={setReverbMixMax}
                        />
                        <SliderControl
                            label="Reverb Time"
                            value={reverbTime}
                            onChange={setReverbTime}
                            min={reverbTimeMin}
                            max={reverbTimeMax}
                            step={0.1}
                            numberStep={0.1}
                            unit="s"
                            decimals={2}
                            inputId="reverbTimeControl"
                            onMinChange={setReverbTimeMin}
                            onMaxChange={setReverbTimeMax}
                        />
                        <SliderControl
                            label="Reverb Decay"
                            value={reverbDecay}
                            onChange={setReverbDecay}
                            min={reverbDecayMin}
                            max={reverbDecayMax}
                            step={0.1}
                            numberStep={0.1}
                            unit=""
                            decimals={2}
                            inputId="reverbDecayControl"
                            onMinChange={setReverbDecayMin}
                            onMaxChange={setReverbDecayMax}
                        />
                    </div>
                </div>
            </div>
        </div>
    </div>
  )
}
ReactDOM.render(React.createElement(App), document.getElementById("app"))
</script>
</body>
</html>
