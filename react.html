<!DOCTYPE html>
<html lang="en-US">
<!-- Simple index.html with in-browser jsx compilation -->
<head>
<title>Synth</title>
<script src="https://unpkg.com/lodash@4.17.21" crossorigin></script>
<script src="https://unpkg.com/@tonejs/midi@2.0.27" crossorigin></script>
<script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-bootstrap@1.5.2/dist/react-bootstrap.js" crossorigin></script>
<script src="https://unpkg.com/react-router-dom@5.2.0/umd/react-router-dom.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone@7.20.12/babel.js"></script>
<!-- Useful things
https://github.com/johndiiorio/react-useinterval/blob/master/src/index.tsx
https://github.com/dance2die/react-use-localstorage/blob/master/src/index.ts
-->
<!-- no 404 request for icon 
<link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">-->
<link href="https://getbootstrap.com/docs/4.6/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<style>
</style>
</head>
<body>
<div id="app"></div>
<script type="text/babel">
const { useState, useEffect, useRef } = React;
const { HashRouter, Link, Route, useRouteMatch } = ReactRouterDOM;
const { Dropdown } = ReactBootstrap;

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const harmonicsCount = 20;

// Helper hook to create state with matching ref for callback access
function useStateWithRef(initialValue) {
    const [state, setState] = useState(initialValue);
    const ref = useRef(initialValue);
    
    useEffect(() => {
        ref.current = state;
    }, [state]);
    
    return [state, setState, ref];
}

function createReverbImpulse(seconds, decay) {
    const rate = audioCtx.sampleRate;
    const length = Math.max(1, Math.floor(seconds * rate));
    const impulse = audioCtx.createBuffer(2, length, rate);
    for (let ch = 0; ch < impulse.numberOfChannels; ch++) {
        const channelData = impulse.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / length;
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - t, decay);
        }
    }
    return impulse;
}

function createCompressor() {
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;  // Start compressing at -24dB
    compressor.knee.value = 30;        // Smooth compression curve
    compressor.ratio.value = 12;       // Strong compression (12:1)
    compressor.attack.value = 0.003;   // Fast attack (3ms)
    compressor.release.value = 0.5;   // Medium release (500ms)
    return compressor;
}

const compressor = createCompressor();
const recordingDestination = audioCtx.createMediaStreamDestination();
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 4096;
analyser.smoothingTimeConstant = 0;
compressor.connect(recordingDestination);
compressor.connect(analyser);
analyser.connect(audioCtx.destination);

function createInstrumentRootNode(config) {
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = config.volume || 1.0;

    const dryGain = audioCtx.createGain();
    dryGain.gain.value = config.dryMix || 0.9;
    dryGain.connect(masterGain);

    const wetGain = audioCtx.createGain();
    wetGain.gain.value = config.wetMix || 0.2;
    wetGain.connect(masterGain);

    const reverbNode = audioCtx.createGain();
    reverbNode.connect(wetGain);

    const convolver = audioCtx.createConvolver();
    convolver.buffer = createReverbImpulse(config.reverb.seconds || 3, config.reverb.decay || 2);
    reverbNode.connect(convolver);
    convolver.connect(wetGain);

    return { masterGain, dryGain, wetGain, reverbNode, convolver };
}

class NoteInstrument {
    constructor() {
        this.rootNode = createInstrumentRootNode({
            volume: 0.7,
            dryMix: 0.8,
            wetMix: 0.3,
            reverb: { seconds: 2, decay: 2 }
        });
        this.rootNode.masterGain.connect(compressor);
        this.noteOscs = {};
        this.envelope = {
            attack: 0.01,
            decay: 0.2,
            sustain: 0.7,
            release: 0.5
        };
        this.harmonicsGamma = 0.5;
        this.evenHarmonicsScale = 1.0;
        this.pitchBend = 0; // in semitones
    }

    setAttack(value) {
        this.envelope.attack = value;
    }

    setDecay(value) {
        this.envelope.decay = value;
    }

    setSustain(value) {
        this.envelope.sustain = value;
    }

    setRelease(value) {
        this.envelope.release = value;
    }

    setVolume(value) {
        this.rootNode.masterGain.gain.setValueAtTime(value, audioCtx.currentTime);
    }

    setReverbMix(value) {
        this.rootNode.wetGain.gain.setValueAtTime(value, audioCtx.currentTime);
        this.rootNode.dryGain.gain.setValueAtTime(1.0 - value, audioCtx.currentTime);
    }

    setReverbTime(seconds, decay) {
        const convolver = this.rootNode.convolver;
        convolver.buffer = createReverbImpulse(seconds, decay);
    }

    _getPreiodicWave() {
        const gamma = this.harmonicsGamma;
        const oddScale = this.evenHarmonicsScale;
        const imag = new Float32Array(harmonicsCount);
        for (let i = 1; i < imag.length; i++) {
            const base = Math.pow(gamma, i);
            imag[i] = (i % 2 === 0) ? base * oddScale : base;
        }
        return audioCtx.createPeriodicWave(
            new Float32Array(harmonicsCount),
            imag,{ disableNormalization: false }
        );
    }

    setHarmonicsGamma(value) {
        this.harmonicsGamma = value;
        const wave = this._getPreiodicWave();
        Object.values(this.noteOscs).forEach(({ osc }) => {
            osc.setPeriodicWave(wave);
        });
    }

    setEvenHarmonicsScale(value) {
        this.evenHarmonicsScale = value;
        const wave = this._getPreiodicWave();
        Object.values(this.noteOscs).forEach(({ osc }) => {
            osc.setPeriodicWave(wave);
        });
    }

    setPitchBend(semitones) {
        this.pitchBend = semitones;
        Object.entries(this.noteOscs).forEach(([note, { osc }]) => {
            const baseFrequency = 440 * Math.pow(2, (Number(note) - 69) / 12);
            const bendedFrequency = baseFrequency * Math.pow(2, semitones / 12);
            osc.frequency.setValueAtTime(bendedFrequency, audioCtx.currentTime);
        });
    }

    startNote(note, velocity = 1.0) {
        const baseFrequency = 440 * Math.pow(2, (note - 69) / 12);
        const noteFrequency = baseFrequency * Math.pow(2, this.pitchBend / 12);
        const noteWavelength = 1 / noteFrequency;
        const attack = Math.max(this.envelope.attack, noteWavelength);
        const existing = this.noteOscs[note];
        if (existing) {
            if (existing.gainNode.gain.value === 0) {
                existing.osc.stop();
                existing.osc.disconnect();
                existing.gainNode.disconnect();
                delete this.noteOscs[note];
            } else {
                existing.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, audioCtx.currentTime);
                existing.gainNode.gain.linearRampToValueAtTime(velocity, audioCtx.currentTime + attack);
                existing.gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, audioCtx.currentTime + attack + this.envelope.decay);
                return;
            }
        }
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.type = 'sine';
        const wave = this._getPreiodicWave();
        osc.setPeriodicWave(wave);
        osc.frequency.value = noteFrequency;

        const now = audioCtx.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(velocity, now + attack);
        gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain, now + attack + this.envelope.decay);

        osc.connect(gainNode);
        gainNode.connect(this.rootNode.dryGain);
        gainNode.connect(this.rootNode.reverbNode);

        osc.start();
        this.noteOscs[note] = { osc, gainNode };
    }

    stopNote(note) {
        const existing = this.noteOscs[note];
        if (existing) {
            const now = audioCtx.currentTime;
            existing.gainNode.gain.cancelScheduledValues(now);
            existing.gainNode.gain.setValueAtTime(existing.gainNode.gain.value, now);
            existing.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
            setTimeout(() => {
                if (existing.gainNode.gain.value === 0) {
                    existing.osc.stop();
                    existing.osc.disconnect();
                    existing.gainNode.disconnect();
                }
            }, this.envelope.release * 1000 + 100);
        }
    }
}

const app = document.getElementById("app");

const instrument = new NoteInstrument();

const getStoredNumber = (key, fallbackValue) => {
    const raw = localStorage.getItem(key);
    if (raw === null || raw === undefined || raw === "") {
        return fallbackValue;
    }
    const parsed = Number(raw);
    return Number.isFinite(parsed) ? parsed : fallbackValue;
};

function SliderControl({
    label,
    value,
    onChange,
    min,
    max,
    step,
    unit,
    decimals = 2,
    numberStep,
    inputId,
    showRangeInputs = true,
    onMinChange,
    onMaxChange,
    onMidiLearn,
    isMidiLearning,
    midiMapping,
    onMidiClear
}) {
    const formatValue = (val) => {
        if (Number.isNaN(val)) {
            return "";
        }
        if (typeof decimals === "number") {
            return Number(val).toFixed(decimals);
        }
        return String(val);
    };

    const handleNumberChange = (e) => {
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const clamped = Math.min(max, Math.max(min, parsed));
            onChange(clamped);
        }
    };

    const handleMinChange = (e) => {
        if (!onMinChange) {
            return;
        }
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const nextMin = Math.min(parsed, max);
            onMinChange(nextMin);
            if (value < nextMin) {
                onChange(nextMin);
            }
        }
    };

    const handleMaxChange = (e) => {
        if (!onMaxChange) {
            return;
        }
        const raw = e.target.value;
        if (raw === "") {
            return;
        }
        const parsed = Number(raw);
        if (!Number.isNaN(parsed)) {
            const nextMax = Math.max(parsed, min);
            onMaxChange(nextMax);
            if (value > nextMax) {
                onChange(nextMax);
            }
        }
    };

    return (
        <div className="form-group mb-3">
            <div className="d-flex align-items-center justify-content-between">
                <label className="form-label mb-1" htmlFor={inputId}>{label}</label>
                <div className="d-flex align-items-center gap-2">
                    {onMidiLearn && (
                        <button
                            className={`btn btn-sm ${isMidiLearning ? 'btn-warning' : 'btn-outline-secondary'}`}
                            onClick={onMidiLearn}
                            title="Click to learn MIDI control"
                        >
                            {isMidiLearning ? 'üéµ Learning...' : 'üéπ'}
                        </button>
                    )}
                    {onMidiClear && midiMapping && (
                        <button
                            className="btn btn-sm btn-outline-danger"
                            onClick={onMidiClear}
                            title="Clear MIDI binding"
                        >
                            ‚úñ
                        </button>
                    )}
                    {midiMapping && (
                        <span className="badge badge-info" title={`CC${midiMapping.cc} CH${midiMapping.channel + 1}`}>
                            CC{midiMapping.cc}
                        </span>
                    )}
                </div>
            {showRangeInputs && (
                <>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Min</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={Number.MIN_SAFE_INTEGER}
                            max={max}
                            step={numberStep || step}
                            value={min}
                            onChange={handleMinChange}
                        />
                    </div>
                    <div className="d-flex align-items-center mr-2">
                        <span className="text-muted small mr-2">Max</span>
                        <input
                            type="number"
                            className="form-control form-control-sm text-right"
                            style={{ width: "90px" }}
                            min={min}
                            max={Number.MAX_SAFE_INTEGER}
                            step={numberStep || step}
                            value={max}
                            onChange={handleMaxChange}
                        />
                    </div>
                    </>
            )}
                <div className="d-flex align-items-center">
                    <input
                        type="number"
                        className="form-control form-control-sm text-right mr-2"
                        style={{ width: "110px" }}
                        min={min}
                        max={max}
                        step={numberStep || step}
                        value={value}
                        onChange={handleNumberChange}
                    />
                    <span className="text-muted small">{formatValue(value)}{unit || ""}</span>
                </div>
            </div>
            <input
                type="range"
                min={min}
                max={max}
                step={step}
                value={value}
                onChange={(e) => onChange(Number(e.target.value))}
                className="form-control-range"
                id={inputId}
            />
        </div>
    );
}

function App() {
    const [isAudioOn, setIsAudioOn] = useState(audioCtx.state === "running");
    const [enableButtonClicked, setEnableButtonClicked] = useState(false);
    const [attack, setAttack] = useState(() => getStoredNumber("attack", 0.01));
    const [decay, setDecay] = useState(() => getStoredNumber("decay", 0.2));
    const [sustain, setSustain] = useState(() => getStoredNumber("sustain", 0.7));
    const [release, setRelease] = useState(() => getStoredNumber("release", 0.5));
    const [volume, setVolume] = useState(() => getStoredNumber("volume", 0.7));
    const [reverbMix, setReverbMix] = useState(() => getStoredNumber("reverbMix", 0.3));
    const [reverbTime, setReverbTime] = useState(() => getStoredNumber("reverbTime", 2));
    const [reverbDecay, setReverbDecay] = useState(() => getStoredNumber("reverbDecay", 2));
    const [harmonicsGamma, setHarmonicsGamma] = useState(() => getStoredNumber("harmonicsGamma", 0.5));
    const [harmonicsGammaMin, setHarmonicsGammaMin] = useState(() => getStoredNumber("harmonicsGammaMin", 0.1));
    const [harmonicsGammaMax, setHarmonicsGammaMax] = useState(() => getStoredNumber("harmonicsGammaMax", 1));
    const [evenHarmonicsScale, setEvenHarmonicsScale] = useState(() => getStoredNumber("evenHarmonicsScale", 0.5));
    const [evenHarmonicsScaleMin, setEvenHarmonicsScaleMin] = useState(() => getStoredNumber("evenHarmonicsScaleMin", 0));
    const [evenHarmonicsScaleMax, setEvenHarmonicsScaleMax] = useState(() => getStoredNumber("evenHarmonicsScaleMax", 1));
    const [pitchBend, setPitchBend] = useState(() => getStoredNumber("pitchBend", 0));
    const [pitchBendMin, setPitchBendMin] = useState(() => getStoredNumber("pitchBendMin", -2));
    const [pitchBendMax, setPitchBendMax] = useState(() => getStoredNumber("pitchBendMax", 2));
    const [attackMin, setAttackMin] = useState(() => getStoredNumber("attackMin", 0.001));
    const [attackMax, setAttackMax] = useState(() => getStoredNumber("attackMax", 1));
    const [decayMin, setDecayMin] = useState(() => getStoredNumber("decayMin", 0.001));
    const [decayMax, setDecayMax] = useState(() => getStoredNumber("decayMax", 2));
    const [sustainMin, setSustainMin] = useState(() => getStoredNumber("sustainMin", 0));
    const [sustainMax, setSustainMax] = useState(() => getStoredNumber("sustainMax", 1));
    const [releaseMin, setReleaseMin] = useState(() => getStoredNumber("releaseMin", 0.001));
    const [releaseMax, setReleaseMax] = useState(() => getStoredNumber("releaseMax", 2));
    const [volumeMin, setVolumeMin] = useState(() => getStoredNumber("volumeMin", 0));
    const [volumeMax, setVolumeMax] = useState(() => getStoredNumber("volumeMax", 1));
    const [reverbMixMin, setReverbMixMin] = useState(() => getStoredNumber("reverbMixMin", 0));
    const [reverbMixMax, setReverbMixMax] = useState(() => getStoredNumber("reverbMixMax", 1));
    const [reverbTimeMin, setReverbTimeMin] = useState(() => getStoredNumber("reverbTimeMin", 0.1));
    const [reverbTimeMax, setReverbTimeMax] = useState(() => getStoredNumber("reverbTimeMax", 6));
    const [reverbDecayMin, setReverbDecayMin] = useState(() => getStoredNumber("reverbDecayMin", 0.5));
    const [reverbDecayMax, setReverbDecayMax] = useState(() => getStoredNumber("reverbDecayMax", 6));
    const [midiAccess, setMidiAccess] = useState(null);
    const [midiInputs, setMidiInputs] = useState([]);
    const [selectedInputIds, setSelectedInputIds] = useState(() => JSON.parse(localStorage.getItem('selectedInputIds')) || []);
    const [midiStatus, setMidiStatus] = useState("MIDI not enabled");
    const [learningControlId, setLearningControlId] = useState(null);
    const [ccMappings, setCcMappings] = useState(() => JSON.parse(localStorage.getItem('ccMappings')) || {});
    const [learnStatus, setLearnStatus] = useState("");
    const [isRecording, setIsRecording, isRecordingRef] = useStateWithRef(false);
    const [recordingTime, setRecordingTime] = useState(0);
    const [recordedChunks, setRecordedChunks] = useState([]);
    const mediaRecorderRef = useRef(null);
    const recordedChunksRef = useRef([]);
    const recordingTimerRef = useRef(null);
    const recordedMidiEventsRef = useRef([]);
    const recordStartTimeRef = useRef(null);
    const activeInputsRef = useRef(new Map());
    const learningControlIdRef = useRef(null);
    const ccMappingsRef = useRef({});
    const adsrCanvasRef = useRef(null);
    const harmonicsCanvasRef = useRef(null);
    const waveformCanvasRef = useRef(null);
    const spectrogramCanvasRef = useRef(null);
    const spectrogramAnimationRef = useRef(null);

  const drawAdsr = () => {
      const canvas = adsrCanvasRef.current;
      if (!canvas) {
          return;
      }
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const sustainT = 0.3;
      const total = attack + decay + release + sustainT;
      const attackW = (attack / total) * width;
      const decayW = (decay / total) * width;
      const releaseW = (release / total) * width;
      const sustainW = (sustainT / total) * width;

      const attackY = height * 0.1;
      const sustainY = height - sustain * (height * 0.8) - height * 0.1;
      const baseY = height - height * 0.1;

      ctx.strokeStyle = "#28a745";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, baseY);
      ctx.lineTo(attackW, attackY);
      ctx.lineTo(attackW + decayW, sustainY);
      ctx.lineTo(attackW + decayW + sustainW, sustainY);
      ctx.lineTo(width, baseY);
      ctx.stroke();

      ctx.fillStyle = "rgba(40, 167, 69, 0.15)";
      ctx.beginPath();
      ctx.moveTo(0, baseY);
      ctx.lineTo(attackW, attackY);
      ctx.lineTo(attackW + decayW, sustainY);
      ctx.lineTo(attackW + decayW + sustainW, sustainY);
      ctx.lineTo(width, baseY);
      ctx.closePath();
      ctx.fill();
  };

  const drawHarmonics = () => {
      const canvas = harmonicsCanvasRef.current;
      if (!canvas) {
          return;
      }
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      const barWidth = width / harmonicsCount;
    const maxValue = Math.max(1, evenHarmonicsScale, harmonicsGamma);

      for (let i = 0; i < harmonicsCount; i++) {
          const base = Math.pow(harmonicsGamma, i);
          const value = (i % 2 === 1) ? base * evenHarmonicsScale : base;
          const barHeight = (value / maxValue) * (height * 0.9);
          const x = i * barWidth;
          const y = height - barHeight;
          ctx.fillStyle = i % 2 === 1 ? "#17a2b8" : "#6c757d";
          ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
      }

      ctx.strokeStyle = "#dee2e6";
      ctx.lineWidth = 1;
      ctx.strokeRect(0, 0, width, height);
  };

  const drawWaveform = () => {
      const canvas = waveformCanvasRef.current;
      if (!canvas) {
          return;
      }
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;
      ctx.clearRect(0, 0, width, height);

      // Generate waveform from harmonics using same algorithm as _getPeriodicWave
      const samples = 512;
      const waveData = new Float32Array(samples);
      
      for (let i = 0; i < samples; i++) {
          const t = (i / samples) * 2 * Math.PI;
          let sum = 0;
          for (let h = 1; h < harmonicsCount; h++) {
              const base = Math.pow(harmonicsGamma, h);
              const amplitude = (h % 2 === 0) ? base * evenHarmonicsScale : base;
              sum += amplitude * Math.sin(h * t);
          }
          waveData[i] = sum;
      }

      // Normalize waveform
      const maxAbs = Math.max(...waveData.map(Math.abs));
      if (maxAbs > 0) {
          for (let i = 0; i < samples; i++) {
              waveData[i] /= maxAbs;
          }
      }

      // Draw waveform
      ctx.strokeStyle = "#007bff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < samples; i++) {
          const x = (i / samples) * width;
          const y = height / 2 - waveData[i] * (height * 0.4);
          if (i === 0) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }
      }
      ctx.stroke();

      // Draw center line
      ctx.strokeStyle = "#dee2e6";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, height / 2);
      ctx.lineTo(width, height / 2);
      ctx.stroke();

      // Draw border
      ctx.strokeRect(0, 0, width, height);
  };

  const drawSpectrogram = () => {
      const canvas = spectrogramCanvasRef.current;
      if (!canvas) {
          return;
      }
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      const nyquist = audioCtx.sampleRate / 2;
      const minFreq = 27.5; // A0
      const maxFreq = 4186.01; // C8
      const logMin = Math.log2(minFreq);
      const logMax = Math.log2(maxFreq);

      const renderFrame = () => {
          analyser.getByteFrequencyData(dataArray);

          // Shift existing image left by 1px
          ctx.drawImage(canvas, -1, 0);

          // Draw the new frequency column on the right
          for (let i = 0; i < bufferLength; i++) {
              const freq = (i / bufferLength) * nyquist;
              if (freq < minFreq || freq > maxFreq) {
                  continue;
              }
              const value = dataArray[i] / 255;
              const logFreq = Math.log2(freq);
              const t = (logFreq - logMin) / (logMax - logMin);
              const y = height - Math.round(t * height);
              const hue = 220 - value * 220;
              const light = 20 + value * 60;
              ctx.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
              ctx.fillRect(width - 1, y, 1, Math.max(1, height / bufferLength));
          }

          spectrogramAnimationRef.current = requestAnimationFrame(renderFrame);
      };

      renderFrame();
  };

  const updateMidiInputs = (access) => {
      const inputs = Array.from(access.inputs.values()).map((input) => ({
          id: input.id,
          name: input.name || "Unknown device",
          manufacturer: input.manufacturer || "Unknown manufacturer"
      }));
      setMidiInputs(inputs);
      if (inputs.length === 0) {
          setMidiStatus("No MIDI inputs found");
      } else {
          setMidiStatus(`${inputs.length} MIDI input${inputs.length === 1 ? "" : "s"} available`);
      }
  };

  const handleEnableMidi = async () => {
      if (!navigator.requestMIDIAccess) {
          setMidiStatus("Web MIDI not supported in this browser");
          return;
      }
      try {
          const access = await navigator.requestMIDIAccess();
          console.log(access);
          setMidiAccess(access);
          updateMidiInputs(access);
          connectSelectedInputs(access, selectedInputIds);
          access.onstatechange = () => updateMidiInputs(access);
      } catch (err) {
          setMidiStatus("MIDI access denied");
      }
  };

  const handleMidiMessage = async (event) => {
      const [status, data1, data2] = event.data;
      const channel = status & 0x0f;
      const command = status & 0xf0;

      // Capture MIDI if recording
      if (isRecordingRef.current && recordStartTimeRef.current) {
          recordedMidiEventsRef.current.push({
              time: Date.now() - recordStartTimeRef.current,
              data: [...event.data]
          });
      }

      // log hex message
      console.log(`MIDI Message: ${[...event.data].map((b) => "0x" + b.toString(16).padStart(2, '0')).join(' ')}`);

      // Handle CC learning mode
      if (learningControlIdRef.current) {
          const cc = data1;
          const newMapping = { ...ccMappingsRef.current };
          newMapping[learningControlIdRef.current] = { channel, cc };
          setCcMappings(newMapping);
          localStorage.setItem('ccMappings', JSON.stringify(newMapping));
          setLearnStatus(`Learned: CC${cc} on channel ${channel + 1}`);
          setLearningControlId(null);
          setTimeout(() => setLearnStatus(""), 2000);
          return;
      }

      // Handle note on/off for playing
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
          setIsAudioOn(true);
      }
      if (command === 0x90) {
          instrument.startNote(data1, data2 / 127);
      } else if (command === 0x80) {
          instrument.stopNote(data1);
      }

      // Handle CC mapping for sliders
      if (true) {
          const cc = data1;
          const value = data2 / 127;
          for (const [controlId, mapping] of Object.entries(ccMappingsRef.current)) {
              if (mapping.channel === channel && mapping.cc === cc) {
                console.log(`Mapped CC${cc} on channel ${channel + 1} to ${controlId} with value ${value}`);
                  handleCcValue(controlId, value);
              }
          }
      }
  };

  const startRecording = () => {
      setRecordedChunks([]);
      recordedMidiEventsRef.current = [];
      recordStartTimeRef.current = Date.now();
      
      const mediaRecorder = new MediaRecorder(recordingDestination.stream, { mimeType: 'audio/webm;codecs=opus' });
      mediaRecorderRef.current = mediaRecorder;
      setRecordingTime(0);
      
      mediaRecorder.ondataavailable = (e) => {
        console.log('Data available:', e.data);
            setRecordedChunks([...recordedChunksRef.current, e.data]);
            const blob = new Blob([e.data], { type: 'audio/webm;codecs=opus' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `organ-recording-${recordStartTimeRef.current}.webm`;
            a.click();
            URL.revokeObjectURL(url);
      };
      
      mediaRecorder.start();
      mediaRecorder.onstop = () => {
          recordedChunksRef.current = recordedChunksRef.current;
      };
      setIsRecording(true);
      
      recordingTimerRef.current = setInterval(() => {
          setRecordingTime(t => t + 1);
      }, 1000);
  };

  const stopRecording = () => {
      if (mediaRecorderRef.current && isRecording) {
          mediaRecorderRef.current.stop();
          setIsRecording(false);
          if (recordingTimerRef.current) {
              clearInterval(recordingTimerRef.current);
          }
          // Download both files after stop. Delay slightly to ensure data is available.
          setTimeout(() => downloadMidiFile(), 100);
      }
  };

    const downloadMidiFile = () => {
        if (recordedMidiEventsRef.current.length === 0) {
            alert('No MIDI recording to download');
            return;
        }
        
        try {
            const Midi = window.Midi;
            if (!Midi) {
                alert('MIDI library not loaded');
                return;
            }
            
            const midi = new Midi();
            midi.header.setTempo(120);
            const track = midi.addTrack();
            
            // Track time in seconds (MIDI uses seconds, our events are in ms)
            let lastNoteStarts = {};
            
            recordedMidiEventsRef.current.forEach(({ time, data }) => {
                const [status, data1, data2] = data;
                const command = status & 0xf0;
                const midiTime = time / 1000; // Convert ms to seconds
                
                if (command === 0x90 && data2 > 0) {
                    // Note on
                    lastNoteStarts[data1] = midiTime;
                } else if (command === 0x80 || (command === 0x90 && data2 === 0)) {
                    // Note off
                    const startTime = lastNoteStarts[data1];
                    if (startTime !== undefined) {
                        const duration = midiTime - startTime;
                        track.addNote({
                            midi: data1,
                            time: startTime,
                            duration: Math.max(0.01, duration)
                        });
                        delete lastNoteStarts[data1];
                    }
                } else if (command === 0xb0) {
                    // CC - add as control change
                    track.addCC({
                        time: midiTime,
                        number: data1,
                        value: data2 / 127
                    });
                }
            });
            
            // Handle any notes still playing at end
            const endTime = Math.max(...recordedMidiEventsRef.current.map(e => e.time)) / 1000;
            Object.entries(lastNoteStarts).forEach(([midiNote, startTime]) => {
                track.addNote({
                    midi: Number(midiNote),
                    time: startTime,
                    duration: Math.max(0.01, endTime - startTime)
                });
            });
            
            // Download the MIDI file
            const blob = new Blob([midi.toArray()], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `organ-recording-${recordStartTimeRef.current}.mid`;
            a.click();
            URL.revokeObjectURL(url);
        } catch (err) {
            alert('Error creating MIDI file: ' + err.message);
            console.error(err);
        }
    };

    const handleCcValue = (controlId, normalizedValue) => {
      const mapping = {
          attackControl: { state: attack, setState: setAttack, min: attackMin, max: attackMax },
          decayControl: { state: decay, setState: setDecay, min: decayMin, max: decayMax },
          sustainControl: { state: sustain, setState: setSustain, min: sustainMin, max: sustainMax },
          releaseControl: { state: release, setState: setRelease, min: releaseMin, max: releaseMax },
          volumeControl: { state: volume, setState: setVolume, min: volumeMin, max: volumeMax },
          reverbMixControl: { state: reverbMix, setState: setReverbMix, min: reverbMixMin, max: reverbMixMax },
          harmonicsGammaControl: { state: harmonicsGamma, setState: setHarmonicsGamma, min: harmonicsGammaMin, max: harmonicsGammaMax },
          evenHarmonicsScaleControl: { state: evenHarmonicsScale, setState: setEvenHarmonicsScale, min: evenHarmonicsScaleMin, max: evenHarmonicsScaleMax },
          reverbTimeControl: { state: reverbTime, setState: setReverbTime, min: reverbTimeMin, max: reverbTimeMax },
          reverbDecayControl: { state: reverbDecay, setState: setReverbDecay, min: reverbDecayMin, max: reverbDecayMax },
          pitchBendControl: { state: pitchBend, setState: setPitchBend, min: pitchBendMin, max: pitchBendMax }
      };

      const control = mapping[controlId];
      if (control) {
          const { min, max, setState } = control;
          const scaledValue = min + normalizedValue * (max - min);
          setState(scaledValue);
      }
  };



  const loadMidiRecording = (file) => {
      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const events = JSON.parse(e.target.result);
              if (Array.isArray(events)) {
                  playMidiRecording(events);
              } else {
                  alert('Invalid MIDI recording format');
              }
          } catch (err) {
              alert('Error loading MIDI recording: ' + err.message);
          }
      };
      reader.readAsText(file);
  };

  const playMidiRecording = (events) => {
      if (!audioCtx.state === 'running') {
          audioCtx.resume();
      }
      events.forEach(({ time, data }) => {
          setTimeout(() => {
              const fakeEvent = { data: new Uint8Array(data) };
              handleMidiMessage(fakeEvent);
          }, time);
      });
  };

  const startMidiLearn = (controlId) => {
      setLearningControlId(controlId);
      setLearnStatus(`Learning ${controlId}... Move a MIDI slider`);
  };

  const clearMidiBinding = (controlId) => {
      const newMapping = { ...ccMappingsRef.current };
      delete newMapping[controlId];
      setCcMappings(newMapping);
      localStorage.setItem('ccMappings', JSON.stringify(newMapping));
  };

  const connectSelectedInputs = (midiAccess, ids) => {
    console.log("Restoring MIDI connections to selected inputs:", selectedInputIds);
      if (!midiAccess) {
          return;
      }
      const activeInputs = activeInputsRef.current;
      const nextIds = new Set(ids);

      for (const [id, input] of activeInputs.entries()) {
          if (!nextIds.has(id)) {
              input.onmidimessage = null;
              activeInputs.delete(id);
          }
      }

      ids.forEach((id) => {
          if (!activeInputs.has(id)) {
              const input = midiAccess.inputs.get(id);
              if (input) {
                  input.onmidimessage = handleMidiMessage;
                  activeInputs.set(id, input);
              }
          }
      });

      if (ids.length === 0) {
          setMidiStatus(midiInputs.length > 0 ? "No MIDI inputs selected" : "No MIDI inputs found");
      } else {
          setMidiStatus(`Connected to ${ids.length} input${ids.length === 1 ? "" : "s"}`);
      }
  };

  const handleMidiSelection = (e) => {
      const options = Array.from(e.target.selectedOptions);
      const ids = options.map((option) => option.value);
      setSelectedInputIds(ids);
      connectSelectedInputs(midiAccess, ids);
  };

  useEffect(() => {
      return () => {
          const activeInputs = activeInputsRef.current;
          for (const input of activeInputs.values()) {
              input.onmidimessage = null;
          }
          activeInputs.clear();
      };
  }, []);

    useEffect(() => {
        handleEnableMidi();
    }, []);

  useEffect(() => {
      localStorage.setItem('attack', attack);
      instrument.setAttack(attack);
  }, [attack]);

  useEffect(() => {
      localStorage.setItem('decay', decay);
      instrument.setDecay(decay);
  }, [decay]);

  useEffect(() => {
      localStorage.setItem('sustain', sustain);
      instrument.setSustain(sustain);
  }, [sustain]);

  useEffect(() => {
      localStorage.setItem('release', release);
      instrument.setRelease(release);
  }, [release]);

  useEffect(() => {
      localStorage.setItem('volume', volume);
      instrument.setVolume(volume);
  }, [volume]);

  useEffect(() => {
      localStorage.setItem('reverbMix', reverbMix);
      instrument.setReverbMix(reverbMix);
  }, [reverbMix]);

  useEffect(() => {
      localStorage.setItem('reverbTime', reverbTime);
      localStorage.setItem('reverbDecay', reverbDecay);
      instrument.setReverbTime(reverbTime, reverbDecay);
  }, [reverbTime, reverbDecay]);

  useEffect(() => {
      localStorage.setItem('harmonicsGamma', harmonicsGamma);
      instrument.setHarmonicsGamma(harmonicsGamma);
  }, [harmonicsGamma]);

  useEffect(() => {
      drawAdsr();
  }, [attack, decay, sustain, release]);

  useEffect(() => {
      drawHarmonics();
      drawWaveform();
  }, [harmonicsGamma, evenHarmonicsScale]);

  useEffect(() => {
      drawSpectrogram();
      return () => {
          if (spectrogramAnimationRef.current) {
              cancelAnimationFrame(spectrogramAnimationRef.current);
              spectrogramAnimationRef.current = null;
          }
      };
  }, []);

  useEffect(() => {
      localStorage.setItem('evenHarmonicsScale', evenHarmonicsScale);
      instrument.setEvenHarmonicsScale(evenHarmonicsScale);
  }, [evenHarmonicsScale]);

  useEffect(() => {
      localStorage.setItem('pitchBend', pitchBend);
      instrument.setPitchBend(pitchBend);
  }, [pitchBend]);

  useEffect(() => {
      localStorage.setItem("attackMin", attackMin);
  }, [attackMin]);

  useEffect(() => {
      localStorage.setItem("attackMax", attackMax);
  }, [attackMax]);

  useEffect(() => {
      localStorage.setItem("decayMin", decayMin);
  }, [decayMin]);

  useEffect(() => {
      localStorage.setItem("decayMax", decayMax);
  }, [decayMax]);

  useEffect(() => {
      localStorage.setItem("sustainMin", sustainMin);
  }, [sustainMin]);

  useEffect(() => {
      localStorage.setItem("sustainMax", sustainMax);
  }, [sustainMax]);

  useEffect(() => {
      localStorage.setItem("releaseMin", releaseMin);
  }, [releaseMin]);

  useEffect(() => {
      localStorage.setItem("releaseMax", releaseMax);
  }, [releaseMax]);

  useEffect(() => {
      localStorage.setItem("volumeMin", volumeMin);
  }, [volumeMin]);

  useEffect(() => {
      localStorage.setItem("volumeMax", volumeMax);
  }, [volumeMax]);

  useEffect(() => {
      localStorage.setItem("reverbMixMin", reverbMixMin);
  }, [reverbMixMin]);

  useEffect(() => {
      localStorage.setItem("reverbMixMax", reverbMixMax);
  }, [reverbMixMax]);

  useEffect(() => {
      localStorage.setItem("reverbTimeMin", reverbTimeMin);
  }, [reverbTimeMin]);

  useEffect(() => {
      localStorage.setItem("reverbTimeMax", reverbTimeMax);
  }, [reverbTimeMax]);

  useEffect(() => {
      localStorage.setItem("reverbDecayMin", reverbDecayMin);
  }, [reverbDecayMin]);

  useEffect(() => {
      localStorage.setItem("reverbDecayMax", reverbDecayMax);
  }, [reverbDecayMax]);

  useEffect(() => {
      localStorage.setItem("harmonicsGammaMin", harmonicsGammaMin);
  }, [harmonicsGammaMin]);

  useEffect(() => {
      localStorage.setItem("harmonicsGammaMax", harmonicsGammaMax);
  }, [harmonicsGammaMax]);

  useEffect(() => {
      localStorage.setItem("evenHarmonicsScaleMin", evenHarmonicsScaleMin);
  }, [evenHarmonicsScaleMin]);

  useEffect(() => {
      localStorage.setItem("evenHarmonicsScaleMax", evenHarmonicsScaleMax);
  }, [evenHarmonicsScaleMax]);

  useEffect(() => {
      localStorage.setItem("pitchBendMin", pitchBendMin);
  }, [pitchBendMin]);

  useEffect(() => {
      localStorage.setItem("pitchBendMax", pitchBendMax);
  }, [pitchBendMax]);

  useEffect(() => {
      localStorage.setItem('selectedInputIds', JSON.stringify(selectedInputIds));
  }, [selectedInputIds]);

  useEffect(() => {
      localStorage.setItem('ccMappings', JSON.stringify(ccMappings));
      ccMappingsRef.current = ccMappings;
  }, [ccMappings]);

  useEffect(() => {
      learningControlIdRef.current = learningControlId;
  }, [learningControlId]);

  const handleAttack = (e) => setAttack(Number(e.target.value));
  const handleDecay = (e) => setDecay(Number(e.target.value));
  const handleSustain = (e) => setSustain(Number(e.target.value));
  const handleRelease = (e) => setRelease(Number(e.target.value));
  const handleVolume = (e) => setVolume(Number(e.target.value));
  const handleReverbMix = (e) => setReverbMix(Number(e.target.value));
  const handleReverbTime = (e) => setReverbTime(Number(e.target.value));
  const handleReverbDecay = (e) => setReverbDecay(Number(e.target.value));

  const handleTurnOn = async () => {
      if (audioCtx.state !== "running") {
          await audioCtx.resume();
      }
      setIsAudioOn(audioCtx.state === "running");
      setEnableButtonClicked(true);
  };

  return (
    <div className="container py-4">
        {!enableButtonClicked && (
            <div 
                style={{
                    position: "fixed",
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 9999
                }}
            >
                <button 
                    className="btn btn-success btn-lg"
                    onClick={handleTurnOn}
                    style={{ fontSize: "32px", padding: "30px 60px", width: "50%", height: "50%" }}
                >
                    Click to Enable
                </button>
            </div>
        )}

        <div className="d-flex align-items-center justify-content-between mb-3">
            <h1 className="h3 mb-0">Audio Instrument</h1>
            <div className="d-flex gap-2">
                <button 
                    className={`btn btn-sm ${isRecording ? 'btn-danger' : 'btn-outline-danger'}`}
                    onClick={isRecording ? stopRecording : startRecording}
                >
                    {isRecording ? `‚èπ Stop & Download (${recordingTime}s)` : '‚è∫ Record'}
                </button>
                {/**
                <button 
                    className="btn btn-sm btn-outline-primary"
                    onClick={downloadMidiFile}
                    disabled={recordedMidiEventsRef.current.length === 0}
                >
                    üíæ Download MIDI
                </button>
                <label className="btn btn-sm btn-outline-secondary mb-0">
                    üìÅ Load MIDI
                    <input type="file" accept=".json" onChange={(e) => e.target.files[0] && loadMidiRecording(e.target.files[0])} style={{display: 'none'}} />
                </label>**/}
            </div>
        </div>

        <div className="card mb-3">
            <div className="card-body">
                <div className="form-group mb-3">
                    <div className="d-flex align-items-center justify-content-between">
                        <label className="form-label mb-0">MIDI Inputs</label>
                        <button className="btn btn-outline-secondary btn-sm" onClick={handleEnableMidi}>
                            {midiAccess ? "Refresh MIDI" : "Enable MIDI"}
                        </button>
                    </div>
                    <small className="text-muted d-block mb-2">{midiStatus}</small>
                    {learnStatus && <small className="text-info d-block mb-2">{learnStatus}</small>}
                    <select
                        className="form-control"
                        multiple
                        value={selectedInputIds}
                        onChange={handleMidiSelection}
                        disabled={!midiAccess || midiInputs.length === 0}
                    >
                        {midiInputs.length === 0 && <option value="">No MIDI devices</option>}
                        {midiInputs.map((input) => (
                            <option key={input.id} value={input.id}>
                                {input.manufacturer} {input.name}
                            </option>
                        ))}
                    </select>
                </div>

                <div className="row">
                    <div className="col-md-6">
                        <h2 className="h5">Envelope</h2>
                        <SliderControl
                            label="Attack"
                            value={attack}
                            onChange={setAttack}
                            min={attackMin}
                            max={attackMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="attackControl"
                            onMinChange={setAttackMin}
                            onMaxChange={setAttackMax}
                            onMidiLearn={() => startMidiLearn('attackControl')}
                            isMidiLearning={learningControlId === 'attackControl'}
                            midiMapping={ccMappings.attackControl}
                            onMidiClear={() => clearMidiBinding('attackControl')}
                        />
                        <SliderControl
                            label="Decay"
                            value={decay}
                            onChange={setDecay}
                            min={decayMin}
                            max={decayMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="decayControl"
                            onMinChange={setDecayMin}
                            onMaxChange={setDecayMax}
                            onMidiLearn={() => startMidiLearn('decayControl')}
                            isMidiLearning={learningControlId === 'decayControl'}
                            midiMapping={ccMappings.decayControl}
                            onMidiClear={() => clearMidiBinding('decayControl')}
                        />
                        <SliderControl
                            label="Sustain"
                            value={sustain}
                            onChange={setSustain}
                            min={sustainMin}
                            max={sustainMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="sustainControl"
                            onMinChange={setSustainMin}
                            onMaxChange={setSustainMax}
                            onMidiLearn={() => startMidiLearn('sustainControl')}
                            isMidiLearning={learningControlId === 'sustainControl'}
                            midiMapping={ccMappings.sustainControl}
                            onMidiClear={() => clearMidiBinding('sustainControl')}
                        />
                        <SliderControl
                            label="Release"
                            value={release}
                            onChange={setRelease}
                            min={releaseMin}
                            max={releaseMax}
                            step={0.001}
                            numberStep={0.001}
                            unit="s"
                            decimals={3}
                            inputId="releaseControl"
                            onMinChange={setReleaseMin}
                            onMaxChange={setReleaseMax}
                            onMidiLearn={() => startMidiLearn('releaseControl')}
                            isMidiLearning={learningControlId === 'releaseControl'}
                            midiMapping={ccMappings.releaseControl}
                            onMidiClear={() => clearMidiBinding('releaseControl')}
                        />
                        <div className="mb-3">
                            <canvas
                                ref={adsrCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                    </div>
                    <div className="col-md-6">
                        <h2 className="h5">Output</h2>
                        <SliderControl
                            label="Volume"
                            value={volume}
                            onChange={setVolume}
                            min={volumeMin}
                            max={volumeMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="volumeControl"
                            onMinChange={setVolumeMin}
                            onMaxChange={setVolumeMax}
                            onMidiLearn={() => startMidiLearn('volumeControl')}
                            isMidiLearning={learningControlId === 'volumeControl'}
                            midiMapping={ccMappings.volumeControl}
                            onMidiClear={() => clearMidiBinding('volumeControl')}
                        />
                        <SliderControl
                            label="Reverb Mix"
                            value={reverbMix}
                            onChange={setReverbMix}
                            min={reverbMixMin}
                            max={reverbMixMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="reverbMixControl"
                            onMinChange={setReverbMixMin}
                            onMaxChange={setReverbMixMax}
                            onMidiLearn={() => startMidiLearn('reverbMixControl')}
                            isMidiLearning={learningControlId === 'reverbMixControl'}
                            midiMapping={ccMappings.reverbMixControl}
                            onMidiClear={() => clearMidiBinding('reverbMixControl')}
                        />
                        <SliderControl
                            label="Reverb Time"
                            value={reverbTime}
                            onChange={setReverbTime}
                            min={reverbTimeMin}
                            max={reverbTimeMax}
                            step={0.1}
                            numberStep={0.1}
                            unit="s"
                            decimals={2}
                            inputId="reverbTimeControl"
                            onMinChange={setReverbTimeMin}
                            onMaxChange={setReverbTimeMax}
                            onMidiLearn={() => startMidiLearn('reverbTimeControl')}
                            isMidiLearning={learningControlId === 'reverbTimeControl'}
                            midiMapping={ccMappings.reverbTimeControl}
                            onMidiClear={() => clearMidiBinding('reverbTimeControl')}
                        />
                        <SliderControl
                            label="Reverb Decay"
                            value={reverbDecay}
                            onChange={setReverbDecay}
                            min={reverbDecayMin}
                            max={reverbDecayMax}
                            step={0.1}
                            numberStep={0.1}
                            unit=""
                            decimals={2}
                            inputId="reverbDecayControl"
                            onMinChange={setReverbDecayMin}
                            onMaxChange={setReverbDecayMax}
                            onMidiLearn={() => startMidiLearn('reverbDecayControl')}
                            isMidiLearning={learningControlId === 'reverbDecayControl'}
                            midiMapping={ccMappings.reverbDecayControl}
                            onMidiClear={() => clearMidiBinding('reverbDecayControl')}
                        />
                        <h2 className="h5 mt-4">Harmonics</h2>
                        <SliderControl
                            label="Harmonics Gamma"
                            value={harmonicsGamma}
                            onChange={setHarmonicsGamma}
                            min={harmonicsGammaMin}
                            max={harmonicsGammaMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="harmonicsGammaControl"
                            onMinChange={setHarmonicsGammaMin}
                            onMaxChange={setHarmonicsGammaMax}
                            onMidiLearn={() => startMidiLearn('harmonicsGammaControl')}
                            isMidiLearning={learningControlId === 'harmonicsGammaControl'}
                            midiMapping={ccMappings.harmonicsGammaControl}
                            onMidiClear={() => clearMidiBinding('harmonicsGammaControl')}
                        />
                        <SliderControl
                            label="Even Harmonics Scale"
                            value={evenHarmonicsScale}
                            onChange={setEvenHarmonicsScale}
                            min={evenHarmonicsScaleMin}
                            max={evenHarmonicsScaleMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=""
                            decimals={2}
                            inputId="evenHarmonicsScaleControl"
                            onMinChange={setEvenHarmonicsScaleMin}
                            onMaxChange={setEvenHarmonicsScaleMax}
                            onMidiLearn={() => startMidiLearn('evenHarmonicsScaleControl')}
                            isMidiLearning={learningControlId === 'evenHarmonicsScaleControl'}
                            midiMapping={ccMappings.evenHarmonicsScaleControl}
                            onMidiClear={() => clearMidiBinding('evenHarmonicsScaleControl')}
                        />
                        <SliderControl
                            label="Pitch Bend"
                            value={pitchBend}
                            onChange={setPitchBend}
                            min={pitchBendMin}
                            max={pitchBendMax}
                            step={0.01}
                            numberStep={0.01}
                            unit=" semitones"
                            decimals={2}
                            inputId="pitchBendControl"
                            onMinChange={setPitchBendMin}
                            onMaxChange={setPitchBendMax}
                            onMidiLearn={() => startMidiLearn('pitchBendControl')}
                            isMidiLearning={learningControlId === 'pitchBendControl'}
                            midiMapping={ccMappings.pitchBendControl}
                            onMidiClear={() => clearMidiBinding('pitchBendControl')}
                        />
                        <div className="mb-3">
                            <canvas
                                ref={harmonicsCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                        <div className="mb-3">
                            <canvas
                                ref={waveformCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#f8f9fa", borderRadius: "6px" }}
                            />
                        </div>
                        <div className="mb-3">
                            <canvas
                                ref={spectrogramCanvasRef}
                                width="320"
                                height="140"
                                style={{ width: "100%", background: "#000", borderRadius: "6px" }}
                            />
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  )
}
ReactDOM.render(React.createElement(App), document.getElementById("app"))
</script>
</body>
</html>
